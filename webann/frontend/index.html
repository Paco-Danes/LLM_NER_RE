<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NER+RE Annotation Tool</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
    <!-- Your CSS moved out of the HTML -->
    <link rel="stylesheet" href="/css/styles.css" />
</head>

<body>
    <div class="app">
        <aside class="sidebar" data-include="/partials/sidebar.html"></aside>
        <main class="main" data-include="/partials/text-area.html"></main>
    </div>
    <div data-include="/partials/modals.html"></div>

    <script type="module">
        import { includePartials } from '/lib/includes.js';
        // 1) Load all HTML partials
        await includePartials();
        // ============== Utility ==============
        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const PALETTE = [
            '#ff0000', '#ff8800', '#fffa00', '#cbff00', '#72ff00',
            '#00ffb3', '#00c9ff', '#0088ff', '#0016ff', '#8d00ff',
            '#b600ff', '#ff00f7', '#ff0075', '#ff004c', '#ffb800',
            '#00f1ff',
        ];

        // map of className → color index
        const CLASS_COLORS = {};
        let nextColorIdx = 0;

        function classColor(klass) {
            // reuse same color if already assigned
            if (!(klass in CLASS_COLORS)) {
                CLASS_COLORS[klass] = PALETTE[nextColorIdx % PALETTE.length];
                nextColorIdx++;
            }
            const base = CLASS_COLORS[klass];
            return {
                bg: base + '66',    // 40% opacity
                chip: base + '44',  // lighter chip
                border: base + '99' // darker border
            };
        }

        function el(tag, props = {}, children = []) {
            const node = document.createElement(tag);
            const { dataset, ...rest } = props;
            Object.assign(node, rest);
            if (dataset) Object.entries(dataset).forEach(([k, v]) => node.dataset[k] = v);
            for (const c of (children || [])) node.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
            return node;
        }

        // Simple tokenizer: keeps whitespace as text nodes, wraps non-whitespace into spans
        function tokenizeWithOffsets(text) {
            const tokens = []; // {text, start, end, isSpace}
            let i = 0;
            const re = /(\s+|\w+|[^\w\s])/gu; // whitespace | word | punctuation/other
            let m;
            while ((m = re.exec(text)) !== null) {
                const tok = m[0];
                const isSpace = /\s/u.test(tok);
                tokens.push({ text: tok, start: i, end: i + tok.length, isSpace });
                i += tok.length;
            }
            return tokens;
        }

        // ============== Global state ==============
        const state = {
            classes: {},
            texts: { cursor: 0, total: 0 },
            current: null, // {id, text}
            tokens: [],
            selection: { startIdx: null, endIdx: null },
            annotations: [], // {id, class, label, attrs, span:{start,end}, tokenRange:[i,j]}
            saved: { exists: false, wasEmpty: false },
            relations: [],              // [{id, predicate|null, subject, object|null, attrs:{}}]
            relationsMeta: {},          // from /api/relations
        };

        const ui = { mode: 'create', editId: null, dragging: false, relEditingId: null };

        function setStatus(msg) { $('#status').textContent = msg; }

        // ============== Backend API helpers ==============
        // --- add this line near the top of the script ---
        const API_BASE = 'http://localhost:8000';

        const API = {
            async getClasses() {
                const r = await fetch(`${API_BASE}/api/classes`);
                if (!r.ok) throw new Error('Failed to load classes');
                return r.json();
            },
            async getNextText(cursor = null) {
                const url = new URL(`${API_BASE}/api/texts/next`);
                if (cursor !== null) url.searchParams.set('cursor', cursor);
                const r = await fetch(url);
                if (!r.ok) throw new Error('Failed to load text');
                return r.json();
            },
            async getPrevText(cursor) {
                const url = new URL(`${API_BASE}/api/texts/prev`);
                url.searchParams.set('cursor', cursor);
                const r = await fetch(url);
                if (!r.ok) throw new Error('Failed to load text');
                return r.json();
            },
            // ADD
            async annotationsExist(text_id) {
                const r = await fetch(`${API_BASE}/api/annotations/${encodeURIComponent(text_id)}/exists`);
                if (!r.ok) throw new Error('Failed to check existing annotations');
                const data = await r.json();
                return !!data.exists;
            },
            // ADD
            async getAnnotation(text_id) {
                const r = await fetch(`${API_BASE}/api/annotations/${encodeURIComponent(text_id)}`);
                if (r.status === 404) return null;
                if (!r.ok) throw new Error('Failed to fetch saved annotation');
                return r.json();
            },
            // CHANGE: support overwrite flag
            async saveAnnotations(payload, overwrite = false) {
                const url = new URL(`${API_BASE}/api/annotations`);
                if (overwrite) url.searchParams.set('overwrite', 'true');
                const r = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!r.ok) throw new Error(await r.text());
                return r.json();
            },
            async getRelations() {
                const r = await fetch(`${API_BASE}/api/relations`);
                if (!r.ok) throw new Error('Failed to load relations');
                return r.json();
            },
            // allow kind parameter for status
            async semanticStatus(kind = 'class') {
                const r = await fetch(`${API_BASE}/api/semantic/status?kind=${encodeURIComponent(kind)}`);
                if (!r.ok) return { ready: false, size: 0, model: "", has_embedder: false };
                return r.json();
            },
            // pass through to backend; include kind when needed
            async semanticSuggest(payload) {
                const r = await fetch(`${API_BASE}/api/semantic/suggest`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!r.ok) throw new Error(await r.text());
                return r.json();
            },
            // NEW: propose a class -> backend appends to proposed_classes.py
            async proposeClass(payload) {
                const r = await fetch(`${API_BASE}/api/proposed-classes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!r.ok) throw new Error(await r.text());
                return r.json();
            },
        };

        // ============== Rendering ==============
        function renderText() {
            const wrap = $('#text');
            wrap.innerHTML = '';
            state.tokens = tokenizeWithOffsets(state.current.text);

            state.tokens.forEach((t, idx) => {
                if (t.isSpace) {
                    wrap.appendChild(document.createTextNode(t.text));
                } else {
                    const span = el('span', {
                        className: 'token',
                        dataset: { idx: String(idx), start: String(t.start), end: String(t.end), selected: 'false' }
                    }, [t.text]);
                    wrap.appendChild(span);
                }
            });

            // Selection via drag only
            $('#text').addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            $('#text').addEventListener('mousemove', onMouseMove);

            applyAnnotationHighlights();
        }

        function applyAnnotationHighlights() {
            $$('.token').forEach(s => { s.style.background = 'transparent'; s.dataset.annotated = 'false'; s.removeAttribute('data-anno-label'); s.dataset.selected = 'false'; });
            for (const anno of state.annotations) {
                const { class: klass } = anno;
                const colors = classColor(klass);
                const [i0, i1] = anno.tokenRange;
                for (let i = i0; i <= i1; i++) {
                    const node = document.querySelector(`.token[data-idx="${i}"]`);
                    if (!node) continue;
                    node.style.background = colors.bg;
                    node.dataset.annotated = 'true';
                    node.setAttribute('data-anno-label', `${anno.class}`);
                }
            }
        }

        function renderLegend() {
            const legend = $('#legend');
            const empty = $('#legend-empty');
            legend.innerHTML = '';

            if (state.annotations.length === 0) { empty.style.display = 'block'; return; }
            empty.style.display = 'none';

            // enable/disable Delete all
            const delAllBtn = $('#btn-delete-all');
            if (delAllBtn) delAllBtn.disabled = (state.annotations.length === 0);

            if (state.annotations.length === 0) {
                empty.style.display = 'block';
                return;
            }
            empty.style.display = 'none';

            // group by class
            const byClass = {};
            for (const a of state.annotations) {
                byClass[a.class] ??= [];
                byClass[a.class].push(a);
            }

            for (const [klass, annos] of Object.entries(byClass)) {
                const colors = classColor(klass);
                const header = el(
                    'div',
                    { className: 'header', style: `background:${colors.chip}; border-bottom:1px solid ${colors.border}` },
                    [klass]
                );

                // build items one-by-one so we can attach both click AND drag handlers
                const itemsDiv = el('div', { className: 'items' });

                for (const a of annos) {
                    const chip = el(
                        'span',
                        {
                            className: 'chip',
                            style: `background:${colors.chip}; border-color:${colors.border}`,
                            dataset: { annoId: a.id },
                            draggable: true            // <-- make it draggable
                        },
                        [a.label || `${klass}`]
                    );

                    // click → edit (same behavior you had)
                    chip.addEventListener('click', () => openModal('edit', a.id));

                    // drag → send the entity id so the relationships section can read it
                    chip.addEventListener('dragstart', (ev) => {
                        ev.dataTransfer.setData('text/plain', a.id); // the entity id like "T3"
                        ev.dataTransfer.effectAllowed = 'copy';
                    });

                    itemsDiv.appendChild(chip);
                }

                const card = el('div', { className: 'class-card' }, [header, itemsDiv]);
                legend.appendChild(card);
            }
        }
        function renderClassDescription() {
            const clsName = $('#sel-class').value;
            const meta = state.classes[clsName];
            const descEl = $('#class-desc');
            descEl.textContent = (meta && meta.description) ? meta.description : '(no description)';
        }

        // --- ADD: pull the current Choices search text (if dropdown is open)
        function getChoicesSearchTerm() {
            // Ensure dropdown exists so the input is in DOM
            if (window.classChoices) window.classChoices.showDropdown();
            const inp = $('#modal-bd .choices__input--cloned');
            return (inp && inp.value.trim()) || '';
        }

        // --- ADD: render semantic suggestions
        function renderSemanticSuggestions(items) {
            const section = $('#sem-suggest-section');
            const box = $('#sem-suggest');
            box.innerHTML = '';

            if (!items || items.length === 0) {
                section.style.display = 'block';
                box.appendChild(el('span', { className: 'empty' }, ['No semantic suggestions.']));
                return;
            }

            for (const it of items) {
                const colors = classColor(it.class_name);
                const chip = el('span', {
                    className: 'chip',
                    style: `background:${colors.chip}; border-color:${colors.border}`,
                    title: it.description || ''
                }, [
                    it.class_name,
                    ' ',
                    el('small', {}, [`${Math.round(it.score * 100)}%`])
                ]);

                chip.addEventListener('click', () => {
                    // Apply selection to Choices/select
                    const sel = $('#sel-class');
                    if (window.classChoices) {
                        window.classChoices.setChoiceByValue(it.class_name); // selects the option
                    }
                    sel.value = it.class_name;
                    sel.dispatchEvent(new Event('change'));
                });

                box.appendChild(chip);
            }
            section.style.display = 'block';
        }

        let relChoices = null;

        function getRelChoicesSearchTerm() {
            if (relChoices) relChoices.showDropdown();
            const inp = $('#rel-modal-bd .choices__input--cloned');
            return (inp && inp.value.trim()) || '';
        }

        // Grouping helper
        function classifyAttrName(name) {
            if (name === 'edge_predicate') return 'predicate';
            if (name.startsWith('subject_')) return 'subject';
            if (name.startsWith('object_')) return 'object';
            return 'statement';
        }

        // Build default (spec) order split into groups
        function splitSpecOrder(attrs) {
            const groups = { subject: [], predicate: [], object: [], statement: [] };
            for (const n of Object.keys(attrs)) {
                groups[classifyAttrName(n)].push(n);
            }
            return groups;
        }

        // REPLACE: grouped render with per-group sorting + contextual labels
        function renderRelAttrFields(relName, prefill = {}, orders = null) {
            const wrap = $('#rel-attrs');
            wrap.innerHTML = '';
            const spec = state.relationsMeta[relName];
            if (!spec) { wrap.appendChild(el('div', { className: 'empty' }, ['No attributes.'])); return; }
            const attrs = spec.attributes || {};

            // Determine baseline grouping
            const specGroups = splitSpecOrder(attrs);

            // If caller passed an orders object {subject:[], object:[], statement:[]}, prefer that;
            // otherwise recover from prefill key order; else fall back to spec order.
            const recovered = { subject: [], object: [], statement: [] };
            if (prefill && Object.keys(prefill).length) {
                for (const k of Object.keys(prefill)) {
                    const g = classifyAttrName(k);
                    if (g === 'subject') recovered.subject.push(k);
                    else if (g === 'object') recovered.object.push(k);
                    else if (g === 'statement') recovered.statement.push(k);
                }
                // Append any missing ones in spec order
                for (const g of ['subject', 'object', 'statement']) {
                    for (const k of specGroups[g]) if (!recovered[g].includes(k)) recovered[g].push(k);
                }
            }

            const useOrders = orders && (orders.subject || orders.object || orders.statement)
                ? {
                    subject: (orders.subject || []).filter(n => attrs[n]).concat(specGroups.subject.filter(n => !(orders.subject || []).includes(n))),
                    object: (orders.object || []).filter(n => attrs[n]).concat(specGroups.object.filter(n => !(orders.object || []).includes(n))),
                    statement: (orders.statement || []).filter(n => attrs[n]).concat(specGroups.statement.filter(n => !(orders.statement || []).includes(n))),
                }
                : (Object.keys(prefill).length ? recovered : specGroups);

            // Containers: Subject list, predicate (fixed), Object list, Statement list
            const subjBox = el('div', { id: 'rel-attrs-subj', className: 'rel-attrs-group' });
            const objBox = el('div', { id: 'rel-attrs-obj', className: 'rel-attrs-group' });
            const stmtBox = el('div', { id: 'rel-attrs-stmt', className: 'rel-attrs-group' });

            // Thin separators
            const hr = () => el('div', { className: 'rel-attrs-sep', style: 'height:1px;background:var(--border);margin:6px 0;' });
            // thin seprator for statemt attrss, dashed and lighter color
            const hrStmt = () => el('div', { className: 'rel-attrs-sep', style: 'height:1px;border-top:1px dashed #5b74a9be;margin:6px 0;' });
            // ----- SUBJECT GROUP -----
            for (const attr of useOrders.subject) {
                const aspec = attrs[attr];
                if (!aspec) continue;

                // Optional entity with no candidates → skip (unchanged behavior)
                if (aspec.kind === 'entity') {
                    const classes = aspec.classes || [];
                    const cands = state.annotations.filter(a => classes.includes(a.class));
                    if (cands.length === 0 && aspec.nullable !== false) continue;
                }

                subjBox.appendChild(buildRelAttrRow(attr, aspec, prefill[attr]));
            }
            wrap.appendChild(subjBox);

            // Separator, Predicate (fixed), Separator
            const hasPred = specGroups.predicate.includes('edge_predicate');
            if (hasPred) {
                wrap.appendChild(hr());
                wrap.appendChild(buildPredicateFixedRow(attrs['edge_predicate'], prefill['edge_predicate']));
                wrap.appendChild(hr());
            } else {
                // If no predicate, still separate subject/object visually
                wrap.appendChild(hr());
            }

            // ----- OBJECT GROUP -----
            for (const attr of useOrders.object) {
                const aspec = attrs[attr];
                if (!aspec) continue;
                if (aspec.kind === 'entity') {
                    const classes = aspec.classes || [];
                    const cands = state.annotations.filter(a => classes.includes(a.class));
                    if (cands.length === 0 && aspec.nullable !== false) continue;
                }
                objBox.appendChild(buildRelAttrRow(attr, aspec, prefill[attr]));
            }
            wrap.appendChild(objBox);

            // Separator before statement attrs only if any exist
            const anyStmt = useOrders.statement.some(n => attrs[n]);
            if (anyStmt) wrap.appendChild(hrStmt());

            // ----- STATEMENT (overall relation) GROUP -----
            for (const attr of useOrders.statement) {
                const aspec = attrs[attr];
                if (!aspec) continue;
                stmtBox.appendChild(buildRelAttrRow(attr, aspec, prefill[attr]));
            }
            if (anyStmt) wrap.appendChild(stmtBox);

            // Wire per-group sorting (no crossing)
            wireRelAttrSorting(subjBox);
            wireRelAttrSorting(objBox);
            wireRelAttrSorting(stmtBox);

            // Contextual labels per group (first stays base; others prefix from above)
            const refresh = () => {
                updateRelAttrContextLabelsGroup(subjBox);
                updateRelAttrContextLabelsGroup(objBox);
                updateRelAttrContextLabelsGroup(stmtBox);
            };
            refresh();
            wrap.addEventListener('change', (e) => {
                if (e.target && (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT')) refresh();
            });
        }

        // Build one attribute row (draggable inside its group)
        function buildRelAttrRow(attr, aspec, value) {
            const row = el('div', {
                className: 'row',
                style: 'align-items:center;gap:10px;',
                dataset: { attr }
            });

            const handle = el('span', {
                className: 'drag-handle',
                title: 'Drag to reorder',
                style: 'cursor:grab;user-select:none;padding:0 6px;font-size:18px;line-height:1;color:var(--muted);'
            }, ['⋮⋮']);

            const label = el('label', {
                className: 'rel-attr-label',
                style: 'width: 200px; color: var(--muted); display:flex; gap:4px; align-items:center;'
            }, [el('span', { className: 'label-txt', dataset: { base: attr } }, [attr])]);

            let input = null;
            const val = value;

            if (aspec.kind === 'enum') {
                input = el('select', { id: `rel-attr-${attr}` }, aspec.enum.map(v => el('option', { value: v }, [v])));
                if (aspec.nullable) {
                    input.insertBefore(el('option', { value: '', textContent: '(none)' }), input.firstChild);
                    if (val === undefined || val === null || val === '') input.value = '';
                    else input.value = String(val);
                } else if (val !== undefined && val !== null) {
                    input.value = String(val);
                }
            } else if (aspec.kind === 'number') {
                input = el('input', { id: `rel-attr-${attr}`, type: 'number', step: 'any', style: 'width:120px' });
                if (val !== undefined && val !== null) input.value = String(val);
            } else if (aspec.kind === 'entity') {
                const classes = aspec.classes || [];
                const cands = state.annotations.filter(a => classes.includes(a.class));
                input = el('select', { id: `rel-attr-${attr}` }, []);
                if (aspec.nullable) input.appendChild(el('option', { value: '', textContent: '(none)' }));
                if (cands.length === 0) {
                    input.disabled = true;
                    input.appendChild(el('option', { value: '', textContent: 'No matching entities in document' }));
                } else {
                    for (const ent of cands) {
                        const labelTxt = `${ent.label} (${ent.class})`;
                        input.appendChild(el('option', { value: ent.id, textContent: labelTxt }));
                    }
                }
                if (val === undefined || val === null || val === '') {
                    if (aspec.nullable) input.value = '';
                } else {
                    input.value = String(val);
                }
            } else {
                input = el('input', { id: `rel-attr-${attr}`, type: 'text' });
                if (val !== undefined && val !== null) input.value = String(val);
            }

            row.appendChild(handle);
            row.appendChild(label);
            row.appendChild(input);
            return row;
        }

        // Fixed middle predicate row (no drag handle)
        function buildPredicateFixedRow(aspec, value) {
            const row = el('div', { className: 'row', style: 'align-items:center;gap:10px;' });
            const label = el('label', {
                className: 'rel-attr-label',
                style: 'width: 200px; color: var(--muted); display:flex; gap:4px; align-items:center;'
            }, [el('span', { className: 'label-txt', dataset: { base: 'edge_predicate' } }, ['edge_predicate'])]);

            let input;
            if (aspec && aspec.kind === 'enum') {
                input = el('select', { id: `rel-attr-edge_predicate` }, aspec.enum.map(v => el('option', { value: v }, [v])));
                if (aspec.nullable) {
                    input.insertBefore(el('option', { value: '', textContent: '(none)' }), input.firstChild);
                    if (value === undefined || value === null || value === '') input.value = '';
                    else input.value = String(value);
                } else if (value !== undefined && value !== null) {
                    input.value = String(value);
                }
            } else {
                input = el('input', { id: `rel-attr-edge_predicate`, type: 'text' });
                if (value !== undefined && value !== null) input.value = String(value);
            }

            // No drag-handle here → non-draggable
            row.appendChild(el('span', { style: 'width:18px' }, [])); // spacer to align
            row.appendChild(label);
            row.appendChild(input);
            return row;
        }

        function renderRelDescription(relName) {
            const spec = state.relationsMeta[relName];
            $('#rel-desc').textContent = (spec && spec.description) ? spec.description : '(no description)';
        }

        // ADD: make #rel-attrs sortable by dragging the handle
        function wireRelAttrSorting(container) {
            let dragRow = null;

            container.querySelectorAll('.row .drag-handle').forEach(handle => {
                const row = handle.closest('.row');
                handle.addEventListener('mousedown', () => {
                    row.setAttribute('draggable', 'true');
                    row.style.opacity = '0.7';
                });
                handle.addEventListener('mouseup', () => {
                    row.removeAttribute('draggable');
                    row.style.opacity = '';
                });
            });

            container.addEventListener('dragstart', (e) => {
                const row = e.target.closest('.row');
                if (!row || !row.hasAttribute('draggable')) { e.preventDefault(); return; }
                dragRow = row;
                e.dataTransfer.effectAllowed = 'move';
            });

            container.addEventListener('dragover', (e) => {
                if (!dragRow) return;
                e.preventDefault();
                const after = getRowAfterPosition(container, e.clientY);
                if (after == null) container.appendChild(dragRow);
                else container.insertBefore(dragRow, after);
            });

            container.addEventListener('drop', () => {
                if (!dragRow) return;
                dragRow.removeAttribute('draggable');
                dragRow.style.opacity = '';
                dragRow = null;
                updateRelAttrContextLabelsGroup(container); // order changed → refresh labels
            });

            container.addEventListener('dragend', () => {
                if (dragRow) {
                    dragRow.removeAttribute('draggable');
                    dragRow.style.opacity = '';
                    dragRow = null;
                    updateRelAttrContextLabelsGroup(container);
                }
            });

            function getRowAfterPosition(container, y) {
                const rows = [...container.querySelectorAll('.row')].filter(r => r !== dragRow);
                let closest = null;
                let closestOffset = Number.NEGATIVE_INFINITY;
                for (const r of rows) {
                    const rect = r.getBoundingClientRect();
                    const offset = y - rect.top - rect.height / 2;
                    if (offset < 0 && offset > closestOffset) {
                        closestOffset = offset;
                        closest = r;
                    }
                }
                return closest;
            }
        }

        function updateRelAttrContextLabelsGroup(container) {
            const rows = [...container.querySelectorAll('.row')];
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const labelEl = row.querySelector('.label-txt');
                const base = labelEl.dataset.base;

                // Don't transform edge_predicate or non subject/object fields here
                if (base === 'edge_predicate') { labelEl.textContent = base; continue; }
                const m = /^(subject|object)_(.+)$/.exec(base);

                // First item of the group → always base
                if (!m || i === 0) { labelEl.textContent = base; continue; }

                // prefix comes from previous row's selection
                const prevInput = rows[i - 1].querySelector('select, input');
                let prefix = '';
                if (prevInput) {
                    if (prevInput.tagName === 'SELECT') {
                        const opt = prevInput.options[prevInput.selectedIndex];
                        prefix = opt ? opt.textContent.trim() : '';
                    } else {
                        prefix = (prevInput.value || '').trim();
                    }
                    prefix = prefix.replace(/\s*\([^)]*\)\s*$/, ''); // strip " (Class)"
                }

                if (prefix) {
                    const suffix = m[2];
                    labelEl.innerHTML = '';
                    labelEl.appendChild(el('span', { style: 'color:#55b5ff;font-weight:600' }, [prefix]));
                    labelEl.appendChild(document.createTextNode('_' + suffix));
                } else {
                    labelEl.textContent = base;
                }
            }
        }

        function entityById(id) { return state.annotations.find(a => a.id === id); }

        // ADD: undirected relation helpers
        function relationAllowedBidirectional(leftClass, rightClass, relName) {
            const spec = state.relationsMeta[relName];
            if (!spec) return false;

            if (!leftClass && !rightClass) return true; // degenerate, allow all

            // Only one participant present: class may be on either side
            if (leftClass && !rightClass) {
                return (spec.subject?.includes(leftClass) || spec.object?.includes(leftClass));
            }
            if (!leftClass && rightClass) {
                return (spec.subject?.includes(rightClass) || spec.object?.includes(rightClass));
            }

            // Both present: match (left→right) OR (right→left)
            const fwd = spec.subject?.includes(leftClass) && spec.object?.includes(rightClass);
            const rev = spec.subject?.includes(rightClass) && spec.object?.includes(leftClass);
            return !!(fwd || rev);
        }

        // ADD: which orientation matches this pair? (when both present)
        function relationOrientationForPair(relName, leftClass, rightClass) {
            const spec = state.relationsMeta[relName];
            if (!spec || !leftClass || !rightClass) return null;
            const fwd = spec.subject?.includes(leftClass) && spec.object?.includes(rightClass);
            const rev = spec.subject?.includes(rightClass) && spec.object?.includes(leftClass);
            if (fwd && !rev) return 'forward';
            if (rev && !fwd) return 'reverse';
            if (fwd && rev) return 'both';
            return null;
        }

        // ADD: with a single entity present, which role does the relation require?
        function firstEntityRoleFor(relName, klass) {
            const spec = state.relationsMeta[relName];
            if (!spec) return null;
            const subjOk = spec.subject?.includes(klass);
            const objOk = spec.object?.includes(klass);
            if (subjOk && !objOk) return 'subject';
            if (!subjOk && objOk) return 'object';
            if (subjOk && objOk) return 'either';
            return null;
        }

        // REPLACE: old getAllowedRelationNames / relationAllowedFor
        function getAllowedRelationNames(leftClass, rightClass = null) {
            const out = [];
            for (const name of Object.keys(state.relationsMeta)) {
                if (relationAllowedBidirectional(leftClass, rightClass, name)) out.push(name);
            }
            return out;
        }

        function swapRelParticipants(rel) {
            const tmp = rel.subject;
            rel.subject = rel.object;
            rel.object = tmp;
        }

        // ADD: small row error helper
        function showRelError(rowEl, msg) {
            const err = rowEl.querySelector('.rel-error');
            if (!err) return;
            err.textContent = msg;
            err.classList.add('show');
            setTimeout(() => err && err.classList.remove('show'), 5000);
        }

        function relRowDOM(rel) {
            const leftEnt = rel.subject ? entityById(rel.subject) : null;
            const rightEnt = rel.object ? entityById(rel.object) : null;

            // chip maker
            const makeChip = (ent) => {
                const colors = classColor(ent.class);
                return el('span', {
                    className: 'rel-chip',
                    style: `background:${colors.chip}; border-color:${colors.border}`
                }, [`${ent.label} (${ent.class})`]);
            };

            // generic placeholder w/ validation against the chosen relation, if any
            const makePlaceholder = (side) => {
                const label = side === 'subject' ? 'drop subject here' : 'drop object here';
                const ph = el('span', { className: 'rel-placeholder', textContent: label });

                ph.addEventListener('dragover', (e) => { e.preventDefault(); ph.classList.add('dragover'); });
                ph.addEventListener('dragleave', () => ph.classList.remove('dragover'));
                ph.addEventListener('drop', (e) => {
                    e.preventDefault(); ph.classList.remove('dragover');
                    const entId = e.dataTransfer.getData('text/plain');
                    if (!entId) return;
                    if ((side === 'subject' && rel.object === entId) || (side === 'object' && rel.subject === entId)) {
                        showRelError(row, 'cannot use the same entity on both sides');
                        return;
                    }
                    const ent = entityById(entId);
                    if (!ent) return;

                    // If a relation is already selected, enforce role-level constraint
                    if (rel.predicate) {
                        const spec = state.relationsMeta[rel.predicate];
                        const ok = side === 'subject' ? spec.subject?.includes(ent.class) : spec.object?.includes(ent.class);
                        if (!ok) {
                            showRelError(row, 'entity type not allowed in this role for this relation');
                            return; // block the placement
                        }
                    }

                    if (side === 'subject') rel.subject = entId; else rel.object = entId;

                    const rowNode = document.querySelector(`.rel-row[data-rel-id="${rel.id}"]`);
                    if (rowNode) rowNode.classList.remove('invalid');
                    ui.dirty = true; updatePrimaryButton();
                    renderRelationships();
                });

                return ph;
            };

            const relBtnLabel = rel.predicate ? rel.predicate : 'Select relation';
            const relBtn = el('button', { className: 'rel-btn ' + (rel.predicate ? 'as-chip' : ''), textContent: relBtnLabel });
            relBtn.onclick = () => openRelModal(rel.id);

            const x = el('button', { className: 'rel-x', textContent: '✕', title: 'Remove relation' });
            x.onclick = () => {
                state.relations = state.relations.filter(r => r.id !== rel.id);
                ui.dirty = true; updatePrimaryButton();
                renderRelationships();
            };

            const row = el('div', { className: 'rel-row', dataset: { relId: rel.id } });

            const leftNode = leftEnt ? makeChip(leftEnt) : makePlaceholder('subject');
            const rightNode = rightEnt ? makeChip(rightEnt) : makePlaceholder('object');

            // Add a spot for inline errors
            const err = el('span', { className: 'rel-error', 'aria-live': 'polite' }, []);

            row.appendChild(leftNode);
            row.appendChild(el('span', { textContent: ' — ' }));
            row.appendChild(relBtn);
            row.appendChild(el('span', { textContent: ' — ' }));
            row.appendChild(rightNode);
            row.appendChild(x);
            row.appendChild(err);

            return row;
        }

        function renderRelationships() {
            const list = $('#rels-list');
            const dz = $('#rels-drop');

            // clear current rows
            list.innerHTML = '';

            // add a row DOM for each relation
            for (const r of state.relations) {
                list.appendChild(relRowDOM(r));
            }

            // ensure the drop zone is visible and positioned AFTER the list
            dz.classList.remove('dragover');
            dz.style.display = ''; // never hide it
            // move it to the end of the wrap so it always appears below existing rows
            if (dz.parentNode !== list.parentNode) {
                // if someone changed HTML later; just append into wrap
                list.parentNode.appendChild(dz);
            } else {
                // keep current parent, just ensure it is after the list
                list.after(dz);
            }
            // (optional) reset its label each render
            dz.textContent = 'Drag an entity chip from the left to start';
        }

        function validateRelations() {
            let ok = true;

            for (const r of state.relations) {
                const row = document.querySelector(`.rel-row[data-rel-id="${r.id}"]`);
                const highlight = (msg) => {
                    ok = false;
                    if (row) {
                        row.classList.add('invalid');
                        showRelError(row, msg || 'Incomplete relation');
                        setTimeout(() => row.classList.remove('invalid'), 900);
                    }
                };

                // Basic completeness
                if (!r.subject || !r.object || !r.predicate || r.predicate.trim() === '') {
                    highlight('Relation needs subject, type, and object');
                    continue;
                }

                // Class-role viability (UI-level check; server will re-validate)
                const spec = state.relationsMeta[r.predicate];
                if (!spec) { highlight('Unknown relation'); continue; }
                const left = entityById(r.subject);
                const right = entityById(r.object);
                if (!left || !right) { highlight('Dangling entity reference'); continue; }

                const fwd = spec.subject?.includes(left.class) && spec.object?.includes(right.class);
                const rev = spec.subject?.includes(right.class) && spec.object?.includes(left.class);
                if (!fwd && !rev) {
                    highlight('Entity classes not allowed for this relation');
                    continue;
                }

                // Attribute-level validation
                const attrs = spec.attributes || {};
                for (const [name, aspec] of Object.entries(attrs)) {
                    const v = (r.attrs || {})[name];

                    if ((v === undefined || v === null || v === '') && aspec.nullable === false) {
                        highlight(`Missing required attribute: ${name}`);
                        break;
                    }
                    if (v === null || v === '' || v === undefined) continue;

                    if (aspec.kind === 'enum') {
                        if (!aspec.enum.includes(v)) { highlight(`'${name}' has invalid value`); break; }
                    } else if (aspec.kind === 'number') {
                        if (Number.isNaN(Number(v))) { highlight(`'${name}' must be a number`); break; }
                    } else if (aspec.kind === 'entity') {
                        const ent = entityById(v);
                        if (!ent || !aspec.classes.includes(ent.class)) {
                            highlight(`'${name}' must refer to a ${aspec.classes.join(' or ')}`);
                            break;
                        }
                    }
                }
            }

            return ok;
        }

        // ============== Selection via drag ==============
        function onMouseDown(e) {
            const node = e.target.closest('.token');
            if (!node) return;
            ui.dragging = true;
            const idx = Number(node.dataset.idx);
            state.selection.startIdx = idx; state.selection.endIdx = idx;
            updateSelectionHighlight();
        }

        function onMouseMove(e) {
            if (!ui.dragging) return;
            const node = e.target.closest('.token');
            if (!node) return;
            const idx = Number(node.dataset.idx);
            state.selection.endIdx = idx;
            if (state.selection.endIdx < state.selection.startIdx) {
                [state.selection.startIdx, state.selection.endIdx] = [state.selection.endIdx, state.selection.startIdx];
            }
            updateSelectionHighlight();
        }

        function onMouseUp() {
            if (!ui.dragging) return;
            ui.dragging = false;
            const { startIdx, endIdx } = state.selection;
            const hasSel = startIdx !== null && endIdx !== null;
            $('#btn-add').disabled = !hasSel;
            $('#btn-add').style = hasSel ? 'border-color: #7aa2f791' : '';
        }

        function updateSelectionHighlight() {
            $$('.token').forEach(s => s.dataset.selected = 'false');
            const { startIdx, endIdx } = state.selection;
            if (startIdx === null || endIdx === null) return;
            for (let i = startIdx; i <= endIdx; i++) {
                const node = document.querySelector(`.token[data-idx="${i}"]`);
                if (node) node.dataset.selected = 'true';
            }
        }

        function clearSelection() {
            state.selection.startIdx = state.selection.endIdx = null;
            updateSelectionHighlight();
            $('#btn-add').disabled = true;
            $('#btn-add').style = '';
        }

        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') clearSelection(); });

        function getEntityCenter(ent) {
            // average center of all tokens in the entity span
            const [i0, i1] = ent.tokenRange;
            const tokens = [];
            for (let i = i0; i <= i1; i++) {
                const node = document.querySelector(`.token[data-idx="${i}"]`);
                if (node) tokens.push(node);
            }
            if (!tokens.length) return null;
            const rects = tokens.map(t => t.getBoundingClientRect());
            const wrapRect = $('.textwrap').getBoundingClientRect();
            const midX = (Math.min(...rects.map(r => r.left)) + Math.max(...rects.map(r => r.right))) / 2;
            const midY = (Math.min(...rects.map(r => r.top)) + Math.max(...rects.map(r => r.bottom))) / 2;
            return { x: midX - wrapRect.left, y: midY - wrapRect.top };
        }

        function drawRelationLinesForEntity(entId) {
            const svg = $('#rel-overlay');
            svg.innerHTML = '';
            const container = $('.textwrap');
            const cRect = container.getBoundingClientRect();
            svg.setAttribute('width', cRect.width);
            svg.setAttribute('height', cRect.height);
            const ent = state.annotations.find(a => a.id === entId);
            if (!ent) return;
            const centerA = getEntityCenter(ent);
            if (!centerA) return;

            const rels = state.relations.filter(r => r.subject === entId || r.object === entId);
            for (const r of rels) {
                const otherId = (r.subject === entId) ? r.object : r.subject;
                const other = state.annotations.find(a => a.id === otherId);
                if (!other) continue;
                const centerB = getEntityCenter(other);
                if (!centerB) continue;

                // simple curved path between A and B
                const dx = (centerB.x - centerA.x);
                const dy = (centerB.y - centerA.y);
                const cx1 = centerA.x + dx / 3;
                const cy1 = centerA.y - 20; // slight curve upward
                const cx2 = centerB.x - dx / 3;
                const cy2 = centerB.y - 20;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M${centerA.x},${centerA.y} C${cx1},${cy1} ${cx2},${cy2} ${centerB.x},${centerB.y}`);
                svg.appendChild(path);

                // midpoint for label
                const midX = (centerA.x + centerB.x) / 2;
                const midY = (centerA.y + centerB.y) / 2 - 12;

                const edgePred = (r.attrs && r.attrs.edge_predicate) ? ` \n[${r.attrs.edge_predicate}]` : '';
                const label = (r.predicate || '(no relation)') + edgePred;

                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.setAttribute('x', midX);
                textEl.setAttribute('y', midY);
                textEl.setAttribute('text-anchor', 'middle');      // ✅ attribute, not CSS
                textEl.setAttribute('dominant-baseline', 'middle'); // ✅ attribute
                textEl.textContent = label;

                const bbox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const textLen = label.length * 6.5 + 8;
                bbox.setAttribute('x', midX - textLen / 2);
                bbox.setAttribute('y', midY - 8);
                bbox.setAttribute('width', textLen);
                bbox.setAttribute('height', 16);
                bbox.setAttribute('rx', 4); // ✅ attribute, rounded corners
                bbox.setAttribute('ry', 4);

                svg.appendChild(bbox);
                svg.appendChild(textEl);
            }
        }

        function clearRelationOverlay() {
            $('#rel-overlay').innerHTML = '';
        }

        // ============== Modal (create/edit) ==============
        function openModal(mode = 'create', annoId = null) {
            ui.mode = mode; ui.editId = annoId;
            const bd = $('#modal-bd');
            bd.style.display = 'flex';

            const title = (mode === 'edit') ? 'Edit Annotation' : 'Add Entity';
            $('#modal-title').textContent = title;

            // Prefill label
            const labelNode = $('#inp-label');
            if (mode === 'create') labelNode.value = surfaceFormFromSelection();

            // Class select
            // Destroy any previous Choices instance (important if modal reused)
            if (window.classChoices) {
                window.classChoices.destroy();
                window.classChoices = null;
            }

            const sel = $('#sel-class');
            sel.innerHTML = '';
            for (const cls of Object.keys(state.classes)) {
                sel.appendChild(el('option', { value: cls }, [cls]));
            }

            // Initialize Choices.js
            window.classChoices = new Choices(sel, {
                searchEnabled: true,      // enable search
                searchPlaceholderValue: 'Search classes…',
                shouldSort: false,        // keep your original order
                maxItemCount: -1,         // no limit
                itemSelectText: '',       // remove “Press to select” hint
                position: 'bottom',       // open downward
                allowHTML: false
            });

            // inside openModal(...), after initializing Choices:
            clearSemanticSuggestions();

            // Check backend readiness once per modal open (cheap call / fast path)
            API.semanticStatus().then(s => {
                const b = $('#btn-sem-find');
                b.disabled = !(s.ready && s.has_embedder && s.size > 0);
                b.title = b.disabled ? 'Semantic index not ready' : 'Send search + label to semantic engine';
            });

            // Listen for changes
            sel.addEventListener('change', () => { renderAttrFields(); renderClassDescription(); });

            // If editing, set current values
            if (mode === 'edit') {
                const anno = state.annotations.find(a => a.id === annoId);
                if (!anno) return;
                labelNode.value = anno.label || '';
                sel.value = anno.class;
                renderAttrFields(anno.attrs);
                renderClassDescription();
                $('#btn-delete').style.display = 'inline-flex';
            } else {
                renderAttrFields();
                renderClassDescription();
                $('#btn-delete').style.display = 'none';
            }
        }

        function closeModal() { $('#modal-bd').style.display = 'none'; }

        // ADD: overwrite modal opener (re-use if you already added earlier)
        function openOverwriteModal(onConfirm, onCancel) {
            const bd = $('#overwrite-bd');
            bd.style.display = 'flex';
            const ok = $('#btn-overwrite-confirm');
            const cancel = $('#btn-overwrite-cancel');
            const cleanup = () => { ok.onclick = cancel.onclick = null; bd.style.display = 'none'; };
            ok.onclick = () => { cleanup(); onConfirm && onConfirm(); };
            cancel.onclick = () => { cleanup(); onCancel && onCancel(); };
        }

        // ADD: Delete All modal opener
        function openDeleteAllModal(onConfirm, onCancel) {
            const bd = $('#delall-bd');
            bd.style.display = 'flex';

            const ok = $('#btn-delall-confirm');
            const cancel = $('#btn-delall-cancel');

            const cleanup = () => {
                ok.onclick = cancel.onclick = null;
                bd.style.display = 'none';
            };
            // on ok click -> delete all button turn disabled    
            ok.onclick = () => { cleanup(); onConfirm && onConfirm(); $('#btn-delete-all').disabled = true; };
            cancel.onclick = () => { cleanup(); onCancel && onCancel(); };
        }

        function openRelModal(relId) {
            ui.relEditingId = relId;
            const rel = state.relations.find(r => r.id === relId);
            if (!rel) return;

            const left = rel.subject ? entityById(rel.subject) : null;
            const right = rel.object ? entityById(rel.object) : null;

            $('#rel-modal-bd').style.display = 'flex';
            const title = `Select Relation (${left ? left.class : '?'} ↔ ${right ? right.class : '?'})`;
            $('#rel-modal-title').textContent = title;

            // (Re)build select with allowed relations (left/right can be null)
            const sel = $('#sel-rel');
            sel.innerHTML = '';
            const allowed = getAllowedRelationNames(left?.class || null, right?.class || null);
            allowed.forEach(name => sel.appendChild(el('option', { value: name }, [name])));

            if (relChoices) { relChoices.destroy(); relChoices = null; }
            relChoices = new Choices(sel, {
                searchEnabled: true, shouldSort: false, itemSelectText: '', position: 'bottom', allowHTML: false
            });

            // preselect if already set and still allowed
            if (rel.predicate && allowed.includes(rel.predicate)) {
                relChoices.setChoiceByValue(rel.predicate);
                sel.value = rel.predicate;
            }

            renderRelAttrFields(sel.value, rel.attrs || {}, rel.attrOrder || null);// {subject:[], object:[], statement:[]}

            renderRelDescription(sel.value);

            sel.addEventListener('change', () => {
                // start fresh for the new type (spec order)
                renderRelAttrFields(sel.value, {}, null);
                renderRelDescription(sel.value);
            });

            API.semanticStatus('relation').then(s => {
                const b = $('#btn-rel-find');
                b.disabled = !(s.ready && s.has_embedder && s.size > 0);
                b.title = b.disabled ? 'Semantic index not ready' : 'Semantic search relations';
            });

            $('#btn-rel-delete').style.display = 'inline-flex';
            $('#btn-rel-delete').onclick = () => {
                state.relations = state.relations.filter(r => r.id !== rel.id);
                $('#rel-modal-bd').style.display = 'none';
                ui.dirty = true; updatePrimaryButton();
                renderRelationships();
            };
        }

        function closeRelModal() { $('#rel-modal-bd').style.display = 'none'; }

        $('#btn-rel-cancel').onclick = closeRelModal;

        $('#btn-rel-confirm').onclick = () => {
            const rel = state.relations.find(r => r.id === ui.relEditingId);
            if (!rel) return;

            const name = $('#sel-rel').value;
            rel.predicate = name;

            // Orientation helpers (unchanged)
            const left = rel.subject ? entityById(rel.subject) : null;
            const right = rel.object ? entityById(rel.object) : null;

            if (left && right) {
                const ori = relationOrientationForPair(name, left.class, right.class);
                if (ori === 'reverse') swapRelParticipants(rel);
            } else if (left && !right) {
                const role = firstEntityRoleFor(name, left.class);
                if (role === 'object') { rel.object = rel.subject; rel.subject = null; }
            } else if (!left && right) {
                const role = firstEntityRoleFor(name, right.class);
                if (role === 'subject') { rel.subject = rel.object; rel.object = null; }
            }
            // Collect attributes in visible order: subject → edge_predicate → object → statement
            const spec = state.relationsMeta[name] || { attributes: {} };
            const out = {};
            const subjectRows = Array.from(document.querySelectorAll('#rel-attrs-subj .row'));
            const objectRows = Array.from(document.querySelectorAll('#rel-attrs-obj .row'));
            const stmtRows = Array.from(document.querySelectorAll('#rel-attrs-stmt .row'));

            // helper to push rows into `out` preserving order
            function pushRows(rows) {
                for (const r of rows) {
                    const attr = r.dataset.attr;
                    const aspec = (spec.attributes || {})[attr];
                    if (!aspec) continue;
                    const node = r.querySelector(`#rel-attr-${attr}`);
                    if (!node) continue;
                    const raw = node.value;

                    if (raw === '' && aspec.nullable) out[attr] = null;
                    else if (aspec.kind === 'number') out[attr] = raw === '' ? null : Number(raw);
                    else out[attr] = raw;
                }
            }

            // subject group
            pushRows(subjectRows);

            // edge_predicate (fixed middle) if present
            if ((spec.attributes || {}).edge_predicate) {
                const node = document.querySelector('#rel-attr-edge_predicate');
                if (node) out['edge_predicate'] = node.value === '' ? null : node.value;
            }

            // object group
            pushRows(objectRows);

            // statement group (overall relation)
            pushRows(stmtRows);

            // Store current per-group order for next modal open
            rel.attrOrder = {
                subject: subjectRows.map(r => r.dataset.attr),
                object: objectRows.map(r => r.dataset.attr),
                statement: stmtRows.map(r => r.dataset.attr)
            };
            rel.attrs = out;

            const row = document.querySelector(`.rel-row[data-rel-id="${rel.id}"]`);
            if (row) row.classList.remove('invalid');

            ui.dirty = true; updatePrimaryButton();
            renderRelationships();
            closeRelModal();
        };

        function renderAttrFields(prefill = {}) {
            const wrap = $('#attrs');
            wrap.innerHTML = '';
            const clsName = $('#sel-class').value;
            const meta = state.classes[clsName];
            if (!meta || !meta.attributes || Object.keys(meta.attributes).length === 0) {
                wrap.appendChild(el('div', { className: 'empty' }, ['No attributes.'])); return;
            }

            for (const [attr, spec] of Object.entries(meta.attributes)) {
                const field = el('div', { className: 'row', style: 'align-items:center' }, [
                    el('label', { style: 'width: 160px; color: var(--muted);' }, [attr]),
                ]);

                let input;
                if (spec.enum) {
                    input = el('select', { id: `attr-${attr}`, style: 'margin-top:5px' }, spec.enum.map(v => el('option', { value: v }, [v])));
                    if (spec.nullable) input.prepend(el('option', { value: '', textContent: '(none)' }));
                } else if (spec.type === 'number') {
                    input = el('input', { id: `attr-${attr}`, type: 'number', step: 'any', placeholder: 'num', style: 'margin-top:5px;width:100px' });
                } else {
                    input = el('input', { id: `attr-${attr}`, type: 'text', placeholder: 'text' });
                }

                // Prefill if provided
                const val = prefill[attr];
                if (val !== undefined && val !== null) {
                    input.value = String(val);
                } else if (val === null && spec.nullable) {
                    input.value = '';
                }

                field.appendChild(input);
                wrap.appendChild(field);
            }
        }

        function clearRelSuggestions() {
            $('#rel-suggest').innerHTML = '';
            $('#rel-suggest-section').style.display = 'none';
        }
        function renderRelSuggestions(items) {
            const section = $('#rel-suggest-section');
            const box = $('#rel-suggest'); box.innerHTML = '';
            if (!items || items.length === 0) {
                section.style.display = 'block';
                box.appendChild(el('span', { className: 'empty' }, ['No semantic suggestions.']));
                return;
            }
            for (const it of items) {
                const chip = el('span', { className: 'chip', title: it.description || '' }, [
                    it.class_name, ' ', el('small', {}, [`${Math.round(it.score * 100)}%`])
                ]);
                chip.addEventListener('click', () => {
                    if (relChoices) relChoices.setChoiceByValue(it.class_name);
                    $('#sel-rel').value = it.class_name;
                    $('#sel-rel').dispatchEvent(new Event('change'));
                });
                box.appendChild(chip);
            }
            section.style.display = 'block';
        }

        $('#btn-rel-find').onclick = async () => {
            const rel = state.relations.find(r => r.id === ui.relEditingId);
            if (!rel) return;
            const left = rel.subject ? entityById(rel.subject) : null;
            const right = rel.object ? entityById(rel.object) : null;
            const query = getRelChoicesSearchTerm();

            try {
                $('#btn-rel-find').classList.add('loading');
                // Let backend return broad suggestions; we filter undirected locally
                const res = await API.semanticSuggest({
                    kind: 'relation',
                    query,
                    top_k: 10,
                    threshold: 0.2,
                    subject_class: null,
                    object_class: null
                });
                const allowedNames = new Set(getAllowedRelationNames(left?.class || null, right?.class || null));
                const filtered = res.items.filter(it => allowedNames.has(it.class_name));
                renderRelSuggestions(filtered);
            } catch (e) {
                alert('Semantic search failed: ' + e.message);
            } finally {
                $('#btn-rel-find').classList.remove('loading');
            }
        };

        function surfaceFormFromSelection() {
            const { startIdx, endIdx } = state.selection;
            if (startIdx === null || endIdx === null) return '';
            const parts = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const t = state.tokens[i];
                if (!t || t.isSpace) continue;
                parts.push(t.text);
                const after = state.tokens[i + 1];
                if (after && after.isSpace) parts.push(after.text);
            }
            return parts.join('').trim();
        }

        function confirmSaveAnnotation() {
            const mode = ui.mode;
            const label = $('#inp-label').value.trim() || surfaceFormFromSelection();
            const klass = $('#sel-class').value;

            // collect attrs
            const attrs = {};
            const meta = state.classes[klass] || { attributes: {} };
            for (const [attr, spec] of Object.entries(meta.attributes || {})) {
                const node = document.querySelector(`#attr-${attr}`);
                if (!node) continue;
                const raw = node.value;
                if (raw === '' && spec.nullable) { attrs[attr] = null; continue; }
                if (spec.type === 'number') attrs[attr] = raw === '' ? null : Number(raw);
                else attrs[attr] = raw;
            }

            if (mode === 'create') {
                const { startIdx, endIdx } = state.selection;
                if (startIdx === null || endIdx === null) return;
                const start = Number(document.querySelector(`.token[data-idx="${startIdx}"]`).dataset.start);
                const end = Number(document.querySelector(`.token[data-idx="${endIdx}"]`).dataset.end);
                const anno = {
                    id: `T${state.annotations.length + 1}`,
                    class: klass,
                    label,
                    attrs,
                    span: { start, end },
                    tokenRange: [startIdx, endIdx]
                };
                state.annotations.push(anno);
            } else if (mode === 'edit') {
                const anno = state.annotations.find(a => a.id === ui.editId);
                if (!anno) return;
                anno.class = klass;
                anno.label = label;
                anno.attrs = attrs;
            }

            ui.dirty = true;
            updatePrimaryButton();
            applyAnnotationHighlights();
            renderLegend();
            closeModal();
            clearSelection();
        }

        function deleteAnnotation() {
            if (ui.mode !== 'edit') return;
            const id = ui.editId;
            state.annotations = state.annotations.filter(a => a.id !== id);
            const removedId = id; // your existing var
            const before = state.relations.length;
            state.relations = state.relations.filter(r => r.subject !== removedId && r.object !== removedId);
            if (state.relations.length !== before) renderRelationships();
            // if no current annotations left, disable Delete all button
            if (state.annotations.length === 0) { $('#btn-delete-all').disabled = true; }
            ui.dirty = true;
            updatePrimaryButton();
            applyAnnotationHighlights();
            renderLegend();
            closeModal();
        }

        // ADD

        function updatePrimaryButton() {
            const btn = $('#btn-save');
            const shouldSkip = state.saved.exists && !ui.dirty; // already annotated & untouched
            btn.textContent = shouldSkip ? 'Skip ▶' : 'Save & Next ▶';
            // Always enabled: we either skip or save
            btn.disabled = false;
        }

        // ADD: map a char-span to token indices (inclusive range)
        function spanToTokenRange(span) {
            const { start, end } = span; // end is exclusive
            let i0 = null, i1 = null;
            for (let i = 0; i < state.tokens.length; i++) {
                const t = state.tokens[i];
                if (t.isSpace) continue;
                if (i0 === null && t.end > start) i0 = i;           // first token that crosses/starts after start
                if (t.start < end) i1 = i;                          // last token whose start is before end
                if (t.start >= end) break;
            }
            if (i0 === null || i1 === null) return null;
            return [i0, i1];
        }

        // ============== Wire up UI ==============
        $('#btn-add').onclick = () => openModal('create');
        $('#btn-cancel').onclick = closeModal;
        $('#btn-confirm').onclick = confirmSaveAnnotation;
        $('#btn-delete').onclick = deleteAnnotation;
        $('#btn-clear').onclick = clearSelection;
        // ADD: Find button
        $('#btn-sem-find').onclick = async () => {
            const btn = $('#btn-sem-find');
            try {
                btn.classList.add('loading');
                const query = getChoicesSearchTerm();  // from Choices search
                const label = $('#inp-label').value.trim(); // the surface form box
                const res = await API.semanticSuggest({ query, label, top_k: 10, threshold: 0.2 });
                renderSemanticSuggestions(res.items);
            } catch (e) {
                console.error(e);
                alert('Semantic search failed: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        };

        // ADD: on openModal, clear previous suggestions
        function clearSemanticSuggestions() {
            $('#sem-suggest').innerHTML = '';
            $('#sem-suggest-section').style.display = 'none';
            // automatically suggest now (call find button)
            $('#btn-sem-find').click();
        }

        $('#btn-save').onclick = async () => {
            try {
                const shouldSkip = state.saved.exists && !ui.dirty;

                if (shouldSkip) {
                    // Just advance without saving
                    setStatus('Skipping…');
                    const data = await API.getNextText(state.texts.cursor + 1);
                    loadTextResponse(data);
                    return;
                }

                // 🚧 block saving if any relation is incomplete
                if (!validateRelations()) {
                    setStatus('Please complete highlighted relationships before saving.');
                    return;
                }

                // Otherwise: Save (may overwrite)
                const payload = buildAnnotationPayload();

                const proceedSave = async (overwrite) => {
                    await API.saveAnnotations(payload, overwrite);
                    ui.dirty = false; // saved
                    updatePrimaryButton();
                    setStatus('Saved. Loading next text…');
                    const data = await API.getNextText(state.texts.cursor + 1);
                    loadTextResponse(data);
                };

                // Fetch existing to decide overwrite confirmation
                const existing = await API.getAnnotation(payload.text_id); // null if none

                if (existing && Array.isArray(existing.entities) && existing.entities.length > 0) {
                    openOverwriteModal(
                        () => proceedSave(true),
                        () => setStatus('Save canceled.')
                    );
                } else {
                    await proceedSave(!!existing); // overwrite=true only if an empty record exists
                }
            } catch (e) {
                console.error(e);
                alert('Save failed: ' + e.message);
            }
        };

        $('#btn-prev').onclick = async () => {
            try {
                const data = await API.getPrevText(Math.max(0, state.texts.cursor - 1));
                loadTextResponse(data);
            } catch (e) { console.error(e); }
        };

        // Delete all annotations for the current text
        $('#btn-delete-all').onclick = () => {
            if (state.annotations.length === 0) return;
            openDeleteAllModal(
                () => {
                    state.annotations = [];
                    state.relations = [];
                    ui.dirty = true;          // user changed the current doc
                    updatePrimaryButton(); // update Save/Skip button
                    applyAnnotationHighlights();
                    renderRelationships();
                    renderLegend();
                    clearSelection();
                    setStatus('All annotations cleared.');
                },
                () => setStatus('Delete all canceled.')
            );
        };

        const relDrop = $('#rels-drop');
        relDrop.addEventListener('dragover', (e) => { e.preventDefault(); relDrop.classList.add('dragover'); });
        relDrop.addEventListener('dragleave', () => relDrop.classList.remove('dragover'));
        relDrop.addEventListener('drop', (e) => {
            e.preventDefault(); relDrop.classList.remove('dragover');
            const entId = e.dataTransfer.getData('text/plain');
            if (!entId) return;
            // new relation with subject = dropped entity
            const rel = {
                id: `R${state.relations.length + 1}`,
                predicate: null,
                subject: entId,
                object: null,
                attrs: {}
            };
            state.relations.push(rel);
            ui.dirty = true; updatePrimaryButton();
            renderRelationships(); // drop zone stays visible under the new row
        });

        // Show lines when hovering entity tokens
        document.addEventListener('mouseover', (e) => {
            const tok = e.target.closest('.token[data-annotated="true"]');
            if (tok) {
                // find which annotation this token belongs to
                const idx = Number(tok.dataset.idx);
                const ent = state.annotations.find(a => idx >= a.tokenRange[0] && idx <= a.tokenRange[1]);
                if (ent) drawRelationLinesForEntity(ent.id);
            }
        });
        document.addEventListener('mouseout', (e) => {
            if (e.target.closest('.token')) clearRelationOverlay();
        });

        // Show lines when hovering relation rows in the list
        $('#rels-list').addEventListener('mouseover', (e) => {
            const row = e.target.closest('.rel-row');
            if (!row) return;
            const relId = row.dataset.relId;
            const rel = state.relations.find(r => r.id === relId);
            if (!rel) return;
            const subj = rel.subject, obj = rel.object;
            const svg = $('#rel-overlay');
            svg.innerHTML = '';
            if (subj && obj) drawRelationLinesForEntity(subj); // draws both ways
        });
        $('#rels-list').addEventListener('mouseout', (e) => {
            if (e.target.closest('.rel-row')) clearRelationOverlay();
        });


        function buildAnnotationPayload() {
            return {
                text_id: state.current.id,
                text: state.current.text,
                entities: state.annotations.map(a => ({
                    id: a.id,
                    class: a.class,
                    label: a.label,
                    span: { start: a.span.start, end: a.span.end },
                    attributes: a.attrs
                })),
                relations: state.relations.map(r => ({
                    id: r.id,
                    predicate: r.predicate || '',
                    subject: r.subject,
                    object: r.object,
                    attributes: r.attrs || {}
                }))
            };
        }

        // REPLACE
        async function loadTextResponse(data) {
            state.current = { id: data.id, text: data.text };
            state.texts.cursor = data.cursor;
            state.texts.total = data.total;

            // Reset local annotations & selection
            state.annotations = [];
            clearSelection();

            // Reset saved flags & hide note by default
            state.saved.exists = false;
            state.saved.wasEmpty = false;
            $('#empty-annot-note').style.display = 'none';

            // Render tokens first
            renderText();

            try {
                const saved = await API.getAnnotation(state.current.id); // null if none
                if (saved && Array.isArray(saved.entities)) {
                    state.saved.exists = true;
                    state.saved.wasEmpty = saved.entities.length === 0;

                    if (state.saved.wasEmpty) {
                        // Informative note under the textbox
                        $('#empty-annot-note').style.display = 'block';
                    }

                    // Map saved entities to UI annotations
                    const annos = [];
                    for (const ent of saved.entities) {
                        const tr = spanToTokenRange(ent.span);
                        if (!tr) continue;
                        annos.push({
                            id: ent.id,
                            class: ent.class,
                            label: ent.label,
                            attrs: ent.attributes || {},
                            span: { start: ent.span.start, end: ent.span.end },
                            tokenRange: tr
                        });
                    }
                    state.annotations = annos;
                    applyAnnotationHighlights();
                    renderLegend();
                    setStatus(`Doc ${data.cursor + 1} / ${data.total} (loaded saved annotations)`);
                } else {
                    // No saved annotation
                    renderLegend();
                    setStatus(`Doc ${data.cursor + 1} / ${data.total}`);
                }
                // Relations (if present)
                state.relations = [];
                if (saved && Array.isArray(saved.relations)) {
                    // Keep only edges referring to existing entities
                    const ids = new Set(state.annotations.map(a => a.id));
                    for (const r of saved.relations) {
                        if (ids.has(r.subject) && ids.has(r.object)) {
                            const keys = Object.keys(r.attributes || {});
                            const subjectOrder = keys.filter(k => k.startsWith('subject_'));
                            const objectOrder = keys.filter(k => k.startsWith('object_'));
                            const statementOrder = keys.filter(k => k !== 'edge_predicate' && !k.startsWith('subject_') && !k.startsWith('object_'));

                            state.relations.push({
                                id: r.id,
                                predicate: r.predicate || null,
                                subject: r.subject,
                                object: r.object,
                                attrs: r.attributes || {},
                                attrOrder: { subject: subjectOrder, object: objectOrder, statement: statementOrder }
                            });
                        }
                    }
                }
                renderRelationships();
            } catch (e) {
                // 404 → no saved annotations
                renderLegend();
                setStatus(`Doc ${data.cursor + 1} / ${data.total}`);
            }
            // Fresh load: untouched
            ui.dirty = false;
            updatePrimaryButton();
        }

        // ---------- Propose Class: overlay + route (#/propose-class) ----------

        function ensureProposeOverlay() {
            let overlay = $('#propose-overlay');
            if (!overlay) {
                overlay = el('div', { id: 'propose-overlay', className: 'page-overlay', style: 'display:none' });
                $('.main').appendChild(overlay);
            }
            return overlay;
        }

        async function showProposePage() {
            const overlay = ensureProposeOverlay();
            if (!overlay.dataset.loaded) {
                const html = await (await fetch('/partials/propose-class.html')).text();
                overlay.innerHTML = html;
                overlay.dataset.loaded = 'true';
                initProposePage();
            }
            overlay.style.display = 'block';
            $('#propose-status').textContent = 'Fill out the class and click Save.';
            if (location.hash !== '#/propose-class') location.hash = '#/propose-class';
        }

        function hideProposePage() {
            const overlay = $('#propose-overlay');
            if (overlay) overlay.style.display = 'none';
            if (location.hash === '#/propose-class') history.replaceState(null, '', ' ');
        }

        window.addEventListener('hashchange', () => {
            if (location.hash === '#/propose-class') showProposePage(); else hideProposePage();
        });

        // Wire the button that opens the page (once the partial is loaded)
        const wireProposeButton = () => {
            const btn = $('#btn-propose');
            if (btn && !btn.dataset.bound) {
                btn.onclick = showProposePage;
                btn.dataset.bound = '1';
            }
        };

        // Call after partials load:
        wireProposeButton();

        // If user refreshed on the route, open it:
        if (location.hash === '#/propose-class') showProposePage();

        // ---------- Propose Class: page logic ----------
        function initProposePage() {
            const list = $('#pc-attr-list');

            const addAttrRow = (prefill = {}) => {
                const row = el('div', { className: 'attr-row' });

                const name = el('input', { type: 'text', placeholder: 'snake_case', value: prefill.name || '' });
                name.pattern = '^[a-z_][a-z0-9_]*$';
                name.title = 'snake_case, letters/numbers/_; must start with a letter or underscore';

                const type = el('select', {});
                ['str', 'int', 'float', 'bool', 'literal', 'list[str]', 'list[int]', 'list[float]', 'list[bool]']
                    .forEach(t => type.appendChild(el('option', { value: t, textContent: t })));
                type.value = prefill.type || 'str';

                // NEW
                const opt = el('input', { type: 'checkbox', title: 'Check if this field is Optional[...]' });

                opt.checked = !!prefill.optional;

                const lit = el('input', { type: 'text', placeholder: 'e.g., CS, PCW, GW', value: (prefill.literal_values || []).join(', ') });
                const desc = el('input', { type: 'text', placeholder: 'Field description', value: prefill.description || '' });

                const del = el('button', { type: 'button', className: 'ghost', textContent: '✕' });
                del.onclick = () => row.remove();

                const litWrap = el('div', { className: 'lit-wrap' }, [lit]);

                const toggleLit = () => {
                    const isLit = type.value === 'literal';
                    litWrap.style.visibility = isLit ? 'visible' : 'hidden';
                    litWrap.style.pointerEvents = isLit ? 'auto' : 'none';
                    if (!isLit) lit.value = '';
                };
                type.addEventListener('change', toggleLit);
                toggleLit();

                row.appendChild(name);
                row.appendChild(type);
                row.appendChild(opt);
                row.appendChild(litWrap);
                row.appendChild(desc);
                row.appendChild(del);

                list.appendChild(row);
            };

            // Add starter row
            if (!list.childElementCount) addAttrRow();

            $('#pc-attr-add').onclick = () => addAttrRow();

            $('#btn-propose-back').onclick = hideProposePage;

            $('#btn-propose-save').onclick = async () => {
                const status = $('#propose-status');
                try {
                    const className = ($('#pc-name').value || '').trim();
                    const doc = ($('#pc-desc').value || '').trim();

                    if (!/^[A-Z][A-Za-z0-9_]*$/.test(className)) {
                        status.textContent = 'Invalid class name. Use CamelCase (e.g., HumanDevelopmentalTimepoint).';
                        return;
                    }
                    const rows = Array.from(list.querySelectorAll('.attr-row'));
                    const seen = new Set();
                    const attrs = [];
                    for (const r of rows) {
                        const [name, type, opt, litWrap, desc, _del] = r.children;
                        const nm = name.value.trim();
                        if (!nm) continue;
                        if (!/^[a-z_][a-z0-9_]*$/.test(nm)) {
                            status.textContent = `Invalid field name "${nm}" (use snake_case).`;
                            return;
                        }
                        if (seen.has(nm)) {
                            status.textContent = `Duplicate field name "${nm}".`;
                            return;
                        }
                        seen.add(nm);

                        const t = type.value;
                        const optional = opt.checked;
                        const description = desc.value.trim();
                        let spec = { name: nm, type: t, optional, description };

                        if (t === 'literal') {
                            const raw = litWrap.querySelector('input').value.trim();
                            const vals = raw ? raw.split(',').map(s => s.trim()).filter(Boolean) : [];
                            if (vals.length === 0) {
                                status.textContent = `Literal field "${nm}" requires at least one value.`;
                                return;
                            }
                            spec.literal_values = vals;
                        }
                        attrs.push(spec);
                    }

                    const payload = { name: className, description: doc, attributes: attrs };

                    status.textContent = 'Saving…';
                    await API.proposeClass(payload);
                    status.textContent = `Saved! Appended class ${className} to proposed_classes.py`;
                    // small QoL: clear form but keep one empty row
                    $('#pc-name').value = '';
                    $('#pc-desc').value = '';
                    list.innerHTML = '';
                    addAttrRow();
                } catch (e) {
                    const msg = (e && e.message) ? e.message : String(e);
                    $('#propose-status').textContent = msg;
                }
            };
        }

        // Also (re)bind the toolbar button after partials load:
        document.addEventListener('partials:loaded', wireProposeButton);

        async function boot() {
            try {
                state.classes = await API.getClasses();
                state.relationsMeta = await API.getRelations();
                const data = await API.getNextText(null);
                loadTextResponse(data);
                renderRelationships();
            } catch (e) { console.error(e); setStatus('Failed to initialize. Is the backend running?'); }
        }

        boot();
    </script>
</body>

</html>