<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NER Annotation Tool</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
    <style>
        :root {
            --bg: #0b0e14;
            --panel: #0f1320;
            --text: #e6e6e6;
            --muted: #9aa4b2;
            --accent: #7aa2f7;
            --border: #1f2536;
            --chip: #151a28;
            --danger: #971a1a;
            --ok: #2ecc71;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font: 15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
            background: linear-gradient(180deg, #0b0e14 0%, #0a1024 100%);
            color: var(--text);
        }

        .app {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: 100vh;
        }

        .sidebar {
            background: var(--panel);
            border-right: 1px solid var(--border);
            padding: 16px;
            overflow: auto;
        }

        .main {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
        }

        .toolbar {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: rgba(12, 16, 28, .6);
            backdrop-filter: blur(6px);
            position: sticky;
            top: 0;
            z-index: 5;
        }

        .toolbar .spacer {
            flex: 1;
        }

        button,
        select,
        input,
        .btn {
            appearance: none;
            border: 1px solid var(--border);
            background: #12182a;
            color: var(--text);
            border-radius: 10px;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
        }

        button:hover {
            filter: brightness(1.07);
        }

        button.primary {
            background: var(--accent);
            border-color: #5a7dde;
            color: #0b0e14;
        }

        button.ghost {
            background: transparent;
        }

        button.warn {
            background: var(--danger);
            border-color: #aa3030;
            color: white;
        }

        button.ok {
            background: var(--ok);
            border-color: #1e9e5a;
            color: #0b0e14;
        }

        /* Disabled button style */
        button:disabled,
        button[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
            filter: none;
            /* prevent hover filter */
            transform: none;
        }

        .bulk-actions {
            margin-top: 12px;
        }

        .textwrap {
            padding: 18px 24px;
            overflow: auto;
        }

        .text {
            background: rgba(17, 23, 40, 0.55);
            border: 1px solid var(--border);
            padding: 18px;
            border-radius: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
            user-select: none;
            /* disable native highlight */
        }

        .token {
            padding: 2px 1px;
            border-radius: 6px;
            position: relative;
            transition: background .1s;
            user-select: none;
        }

        .token[data-selected="true"] {
            background: rgba(122, 162, 247, 0.25);
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }

        .token[data-annotated="true"] {
            cursor: help;
        }

        .token[data-annotated="true"]::after {
            content: attr(data-anno-label);
            position: absolute;
            left: 0;
            bottom: 100%;
            transform: translateY(-6px);
            font-size: 11px;
            background: #0f1320;
            color: var(--muted);
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid var(--border);
            opacity: 0;
            pointer-events: none;
            white-space: nowrap;
            transition: opacity .12s ease;
        }

        .token[data-annotated="true"]:hover::after {
            opacity: 1;
        }

        .legend {
            display: grid;
            gap: 10px;
        }

        .legend h2 {
            margin: 0 0 8px;
            font-size: 14px;
            color: var(--muted);
            letter-spacing: .08em;
            text-transform: uppercase;
        }

        .class-card {
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
        }

        .class-card .header {
            padding: 10px 12px;
            font-weight: 800;
        }

        .class-card .items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 12px 12px;
        }

        .chip {
            background: var(--chip);
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 12px;
            cursor: pointer;
        }

        .empty {
            color: var(--muted);
            font-style: italic;
        }

        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        .modal {
            width: min(800px, calc(100% - 32px));
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 14px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, .5);
        }

        .modal .head {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border);
            font-weight: 800;
        }

        .modal .body {
            padding: 16px;
            display: grid;
            gap: 12px;
        }

        .modal .foot {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            justify-content: space-between;
            align-items: center;
        }

        .field {
            display: grid;
            gap: 6px;
        }

        /* ==== Custom dark theme for Choices.js ==== */

        .choices {
            --choice-bg: #12182a;
            --choice-border: #2a3248;
            --choice-hover: #1f253a;
            --choice-text: #e6e6e6;
            --choice-placeholder: #9aa4b2;
            --choice-accent: #7aa2f7;
        }

        /* Container */
        .choices {
            background: var(--choice-bg);
            color: var(--choice-text);
            border: 1px solid var(--choice-border);
            border-radius: 10px;
            font-size: 14px;
            width: 100%;
        }

        /* When focused (active dropdown) */
        .choices.is-focused {
            border-color: var(--choice-accent);
            box-shadow: 0 0 0 2px rgba(122, 162, 247, 0.25);
        }

        /* Selected item (the box visible when closed) */
        .choices__inner {
            background: var(--choice-bg);
            color: var(--choice-text);
            border: none;
            border-radius: 10px;
            padding: 8px 10px;
        }

        /* Dropdown panel */
        .choices__list--dropdown,
        .choices__list[aria-expanded] {
            background: #0f1320;
            border: 1px solid var(--choice-border);
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            color: var(--choice-text);
            /* no max-height or overflow here */
            overflow: visible;
        }

        /* ✅ only the inner list gets a scrollbar */
        .choices__list--dropdown .choices__list {
            max-height: 240px;
            overflow-y: auto;
        }

        /* optional: thin scrollbar styling (Firefox) */
        .choices__list--dropdown .choices__list {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, .2) transparent;
        }

        /* Individual options */
        .choices__list--dropdown .choices__item {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .choices__list--dropdown .choices__item:last-child {
            border-bottom: none;
        }

        .choices__list--dropdown .choices__item.is-highlighted,
        .choices__list--dropdown .choices__item:hover {
            background-color: var(--choice-hover) !important;
            /* use !important to override inline style */
            color: var(--choice-text);
        }

        /* Placeholder text */
        .choices__placeholder {
            color: var(--choice-placeholder);
        }

        /* Hide the “Press to select” hint */
        .choices__item--selectable::after {
            display: none;
        }

        .choices__list--dropdown {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }

        /* Search input at the top of the dropdown */
        .choices__input.choices__input--cloned {
            background-color: #2d395f !important;
            /* same as modal background */
            color: #e6e6e6;
            /* text color */
            border: 1px solid var(--border);
            /* subtle border */
            border-radius: 8px;
            padding: 6px 10px;
            margin: 6px;
        }

        .choices__input.choices__input--cloned::placeholder {
            color: #7c8798;
        }

        .row {
            display: flex;
            gap: 8px;
        }

        .field label {
            font-size: 12px;
            color: var(--muted);
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #0a0f1d;
            border: 1px solid var(--border);
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 12px;
            color: var(--muted);
        }

        .footer {
            padding: 10px 16px;
            border-top: 1px solid var(--border);
            color: var(--muted);
        }

        .cols {
            display: grid;
            grid-template-columns: minmax(240px, max-content) 1fr;
            gap: 16px;
            align-items: start;
        }

        /* Stack on narrow screens */
        @media (max-width: 720px) {
            .cols {
                grid-template-columns: 1fr;
            }
        }

        .desc-panel {
            border-left: 1px solid var(--border);
            padding-left: 16px;
            color: var(--muted);
            min-width: 220px;
            /* ensures room for the description */
        }

        .desc-box {
            max-height: 160px;
            /* limit vertical growth */
            overflow-y: auto;
            /* scroll when content exceeds max height */
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
            white-space: pre-wrap;
            font-size: 13px;
            line-height: 1.4;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 10px;
        }

        /* ADD */
        #btn-sem-find.loading {
            position: relative;
            pointer-events: none;
            opacity: .7;
        }

        #btn-sem-find.loading::after {
            content: '…';
            margin-left: 6px;
            animation: blink 1s steps(1) infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        /* Optional: make suggestion chips a bit tighter in this block */
        #sem-suggest .chip {
            padding: 3px 8px;
        }

        #sem-suggest small {
            opacity: .7;
            margin-left: 4px;
            font-size: 11px;
        }

        /* Top block now splits the modal: left (inputs) | right (find + chips) */
        .cols-top {
            display: grid;
            grid-template-columns: 1fr 1fr;
            /* halves the modal */
            gap: 16px;
            align-items: start;
        }

        /* Chips and button niceties on the right rail */
        .right-rail .items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .w-full {
            width: 100%;
        }

        /* Make the two halves stack on small screens */
        @media (max-width: 720px) {
            .cols-top {
                grid-template-columns: 1fr;
            }
        }

        /* Keep from ballooning vertically */
        #sem-suggest {
            max-height: 140px;
            overflow: auto;
            scrollbar-width: thin;
        }
    </style>
</head>

<body>
    <div class="app">
        <aside class="sidebar">
            <div>
                <h2 style="margin-top:0">Annotations</h2>
                <p class="empty" id="legend-empty">No annotations yet.</p>
                <div class="legend" id="legend"></div>
                <!-- Bulk actions -->
                <div class="bulk-actions">
                    <button id="btn-delete-all" class="warn" disabled>Delete all</button>
                </div>
            </div>
            <hr style="border-color:var(--border); margin: 16px 0; border-style: solid; opacity:.6">
            <div>
                <h2>Help</h2>
                <ul style="margin:0; padding-left: 18px; color: var(--muted)">
                    <li>Click–drag across tokens to select words.</li>
                    <li>Press <span class="kbd">Esc</span> to clear selection.</li>
                </ul>
            </div>
        </aside>

        <main class="main">
            <div class="toolbar">
                <button id="btn-add" disabled>Add Class</button>
                <button id="btn-clear" class="ghost">Clear Selection</button>
                <div class="spacer"></div>
                <button id="btn-prev" class="ghost">Prev</button>
                <button id="btn-save" class="primary">Save & Next ▶</button>
            </div>
            <div class="textwrap">
                <div class="text" id="text"></div>
                <p id="empty-annot-note" class="empty" style="display:none; margin:8px 2px 0;">
                    <em>Text already annotated as EMPTY</em>
                </p>
            </div>

            <div class="footer" id="status">Ready.</div>
        </main>
    </div>

    <!-- Modal for adding/editing class/attributes -->
    <div class="modal-backdrop" id="modal-bd">
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
            <div class="head" id="modal-title">Add Class</div>
            <div class="body">
                <!-- TOP: two columns — left form fields, right rail -->
                <div class="cols-top">
                    <!-- LEFT: label + class (each now half the modal because of the grid) -->
                    <div class="col">
                        <div class="field">
                            <label>Label (defaults to selected surface form)</label>
                            <input id="inp-label" type="text" placeholder="Surface form" />
                        </div>

                        <div class="field">
                            <label>Class</label>
                            <select id="sel-class"></select>
                        </div>
                    </div>

                    <!-- RIGHT: find button + suggestions (stacked) -->
                    <div class="col right-rail">
                        <div class="field" style="align-items:flex-end">
                            <label>Genius Search</label>
                            <button id="btn-sem-find" class="ghost" title="Send search text + label to semantic engine"
                                style="width: min-content;padding-left: 30px;padding-right: 30px;">✨Find✨</button>
                        </div>

                        <div class="field" id="sem-suggest-section" style="display:none">
                            <label>Semantic suggestions</label>
                            <div id="sem-suggest" class="items"></div>
                        </div>
                    </div>
                </div>

                <!-- BELOW: keep your existing two-column Attributes | Class description block -->
                <div class="cols">
                    <div class="col">
                        <div class="field">
                            <label>Attributes</label>
                            <div id="attrs"></div>
                        </div>
                    </div>

                    <div class="col desc-panel">
                        <div class="field">
                            <label>Class description</label>
                            <div id="class-desc" class="desc-box"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="foot">
                <button id="btn-delete" class="warn" style="display:none">Delete</button>
                <div style="display:flex; gap:8px; margin-left:auto">
                    <button id="btn-cancel" class="ghost">Cancel</button>
                    <button id="btn-confirm" class="primary">Save</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Overwrite confirmation modal -->
    <div class="modal-backdrop" id="overwrite-bd">
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="overwrite-title">
            <div class="head" id="overwrite-title">Overwrite existing annotations?</div>
            <div class="body">
                <p>
                    The selected text was already annotated.<br>
                    Do you want to overwrite? <br>
                    <small style="color:var(--muted)">This <b>removes all previous entities and relationships</b> and
                        assigns yours.</small>
                </p>
            </div>
            <div class="foot">
                <button id="btn-overwrite-cancel" class="warn">Cancel</button>
                <button id="btn-overwrite-confirm" class="ok">Overwrite</button>
            </div>
        </div>
    </div>

    <!-- ADD: Delete All confirmation modal -->
    <div class="modal-backdrop" id="delall-bd">
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="delall-title">
            <div class="head" id="delall-title">Delete all annotations?</div>
            <div class="body">
                <p>
                    This will remove <b>all annotations</b> for the current text in the UI.<br>
                    (You’ll still need to click <i>Save & Next</i> to persist the empty set.)
                </p>
            </div>
            <div class="foot">
                <button id="btn-delall-cancel" class="ghost">Cancel</button>
                <button id="btn-delall-confirm" class="warn">Delete All</button>
            </div>
        </div>
    </div>


    <script>
        // ============== Utility ==============
        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const PALETTE = [
            '#ff0000', '#ff8800', '#fffa00', '#cbff00', '#72ff00',
            '#00ffb3', '#00c9ff', '#0088ff', '#0016ff', '#8d00ff',
            '#b600ff', '#ff00f7', '#ff0075', '#ff004c', '#ffb800',
            '#00f1ff',
        ];

        // map of className → color index
        const CLASS_COLORS = {};
        let nextColorIdx = 0;

        function classColor(klass) {
            // reuse same color if already assigned
            if (!(klass in CLASS_COLORS)) {
                CLASS_COLORS[klass] = PALETTE[nextColorIdx % PALETTE.length];
                nextColorIdx++;
            }
            const base = CLASS_COLORS[klass];
            return {
                bg: base + '66',    // 40% opacity
                chip: base + '44',  // lighter chip
                border: base + '99' // darker border
            };
        }

        function el(tag, props = {}, children = []) {
            const node = document.createElement(tag);
            const { dataset, ...rest } = props;
            Object.assign(node, rest);
            if (dataset) Object.entries(dataset).forEach(([k, v]) => node.dataset[k] = v);
            for (const c of (children || [])) node.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
            return node;
        }

        // Simple tokenizer: keeps whitespace as text nodes, wraps non-whitespace into spans
        function tokenizeWithOffsets(text) {
            const tokens = []; // {text, start, end, isSpace}
            let i = 0;
            const re = /(\s+|\w+|[^\w\s])/gu; // whitespace | word | punctuation/other
            let m;
            while ((m = re.exec(text)) !== null) {
                const tok = m[0];
                const isSpace = /\s/u.test(tok);
                tokens.push({ text: tok, start: i, end: i + tok.length, isSpace });
                i += tok.length;
            }
            return tokens;
        }

        // ============== Global state ==============
        const state = {
            classes: {},
            texts: { cursor: 0, total: 0 },
            current: null, // {id, text}
            tokens: [],
            selection: { startIdx: null, endIdx: null },
            annotations: [], // {id, class, label, attrs, span:{start,end}, tokenRange:[i,j]}
            saved: { exists: false, wasEmpty: false }
        };

        const ui = { mode: 'create', editId: null, dragging: false };

        function setStatus(msg) { $('#status').textContent = msg; }

        // ============== Backend API helpers ==============
        // --- add this line near the top of the script ---
        const API_BASE = 'http://localhost:8000';

        const API = {
            async getClasses() {
                const r = await fetch(`${API_BASE}/api/classes`);
                if (!r.ok) throw new Error('Failed to load classes');
                return r.json();
            },
            async getNextText(cursor = null) {
                const url = new URL(`${API_BASE}/api/texts/next`);
                if (cursor !== null) url.searchParams.set('cursor', cursor);
                const r = await fetch(url);
                if (!r.ok) throw new Error('Failed to load text');
                return r.json();
            },
            async getPrevText(cursor) {
                const url = new URL(`${API_BASE}/api/texts/prev`);
                url.searchParams.set('cursor', cursor);
                const r = await fetch(url);
                if (!r.ok) throw new Error('Failed to load text');
                return r.json();
            },
            // ADD
            async annotationsExist(text_id) {
                const r = await fetch(`${API_BASE}/api/annotations/${encodeURIComponent(text_id)}/exists`);
                if (!r.ok) throw new Error('Failed to check existing annotations');
                const data = await r.json();
                return !!data.exists;
            },
            // ADD
            async getAnnotation(text_id) {
                const r = await fetch(`${API_BASE}/api/annotations/${encodeURIComponent(text_id)}`);
                if (r.status === 404) return null;
                if (!r.ok) throw new Error('Failed to fetch saved annotation');
                return r.json();
            },
            // CHANGE: support overwrite flag
            async saveAnnotations(payload, overwrite = false) {
                const url = new URL(`${API_BASE}/api/annotations`);
                if (overwrite) url.searchParams.set('overwrite', 'true');
                const r = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!r.ok) throw new Error(await r.text());
                return r.json();
            },
            // ADD to API
            async semanticStatus() {
                const r = await fetch(`${API_BASE}/api/semantic/status`);
                if (!r.ok) return { ready: false, size: 0, model: "", has_embedder: false };
                return r.json();
            },
            async semanticSuggest(payload) {
                const r = await fetch(`${API_BASE}/api/semantic/suggest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!r.ok) throw new Error(await r.text());
                return r.json();
            },

        };

        // ============== Rendering ==============
        function renderText() {
            const wrap = $('#text');
            wrap.innerHTML = '';
            state.tokens = tokenizeWithOffsets(state.current.text);

            state.tokens.forEach((t, idx) => {
                if (t.isSpace) {
                    wrap.appendChild(document.createTextNode(t.text));
                } else {
                    const span = el('span', {
                        className: 'token',
                        dataset: { idx: String(idx), start: String(t.start), end: String(t.end), selected: 'false' }
                    }, [t.text]);
                    wrap.appendChild(span);
                }
            });

            // Selection via drag only
            $('#text').addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            $('#text').addEventListener('mousemove', onMouseMove);

            applyAnnotationHighlights();
        }

        function applyAnnotationHighlights() {
            $$('.token').forEach(s => { s.style.background = 'transparent'; s.dataset.annotated = 'false'; s.removeAttribute('data-anno-label'); s.dataset.selected = 'false'; });
            for (const anno of state.annotations) {
                const { class: klass } = anno;
                const colors = classColor(klass);
                const [i0, i1] = anno.tokenRange;
                for (let i = i0; i <= i1; i++) {
                    const node = document.querySelector(`.token[data-idx="${i}"]`);
                    if (!node) continue;
                    node.style.background = colors.bg;
                    node.dataset.annotated = 'true';
                    node.setAttribute('data-anno-label', `${anno.class}`);
                }
            }
        }

        function renderLegend() {
            const legend = $('#legend');
            const empty = $('#legend-empty');
            legend.innerHTML = '';

            if (state.annotations.length === 0) { empty.style.display = 'block'; return; }
            empty.style.display = 'none';

            // enable/disable Delete all
            const delAllBtn = $('#btn-delete-all');
            if (delAllBtn) delAllBtn.disabled = (state.annotations.length === 0);

            if (state.annotations.length === 0) {
                empty.style.display = 'block';
                return;
            }
            empty.style.display = 'none';

            // group by class
            const byClass = {};
            for (const a of state.annotations) {
                byClass[a.class] ??= [];
                byClass[a.class].push(a);
            }

            for (const [klass, annos] of Object.entries(byClass)) {
                const colors = classColor(klass);
                const card = el('div', { className: 'class-card' }, [
                    el('div', { className: 'header', style: `background:${colors.chip}; border-bottom:1px solid ${colors.border}` }, [klass]),
                    el('div', { className: 'items' }, annos.map(a => el('span', { className: 'chip', style: `background:${colors.chip}; border-color:${colors.border}`, dataset: { annoId: a.id } }, [a.label || `${klass}`])))
                ]);
                // chip click → edit
                card.querySelectorAll('.chip').forEach(ch => ch.addEventListener('click', () => openModal('edit', ch.dataset.annoId)));
                legend.appendChild(card);
            }
        }
        function renderClassDescription() {
            const clsName = $('#sel-class').value;
            const meta = state.classes[clsName];
            const descEl = $('#class-desc');
            descEl.textContent = (meta && meta.description) ? meta.description : '(no description)';
        }

        // --- ADD: pull the current Choices search text (if dropdown is open)
        function getChoicesSearchTerm() {
            // Ensure dropdown exists so the input is in DOM
            if (window.classChoices) window.classChoices.showDropdown();
            const inp = $('#modal-bd .choices__input--cloned');
            return (inp && inp.value.trim()) || '';
        }

        // --- ADD: render semantic suggestions
        function renderSemanticSuggestions(items) {
            const section = $('#sem-suggest-section');
            const box = $('#sem-suggest');
            box.innerHTML = '';

            if (!items || items.length === 0) {
                section.style.display = 'block';
                box.appendChild(el('span', { className: 'empty' }, ['No semantic suggestions.']));
                return;
            }

            for (const it of items) {
                const colors = classColor(it.class_name);
                const chip = el('span', {
                    className: 'chip',
                    style: `background:${colors.chip}; border-color:${colors.border}`,
                    title: it.description || ''
                }, [
                    it.class_name,
                    ' ',
                    el('small', {}, [`${Math.round(it.score * 100)}%`])
                ]);

                chip.addEventListener('click', () => {
                    // Apply selection to Choices/select
                    const sel = $('#sel-class');
                    if (window.classChoices) {
                        window.classChoices.setChoiceByValue(it.class_name); // selects the option
                    }
                    sel.value = it.class_name;
                    sel.dispatchEvent(new Event('change'));
                });

                box.appendChild(chip);
            }
            section.style.display = 'block';
        }

        // ============== Selection via drag ==============
        function onMouseDown(e) {
            const node = e.target.closest('.token');
            if (!node) return;
            ui.dragging = true;
            const idx = Number(node.dataset.idx);
            state.selection.startIdx = idx; state.selection.endIdx = idx;
            updateSelectionHighlight();
        }

        function onMouseMove(e) {
            if (!ui.dragging) return;
            const node = e.target.closest('.token');
            if (!node) return;
            const idx = Number(node.dataset.idx);
            state.selection.endIdx = idx;
            if (state.selection.endIdx < state.selection.startIdx) {
                [state.selection.startIdx, state.selection.endIdx] = [state.selection.endIdx, state.selection.startIdx];
            }
            updateSelectionHighlight();
        }

        function onMouseUp() {
            if (!ui.dragging) return;
            ui.dragging = false;
            const { startIdx, endIdx } = state.selection;
            const hasSel = startIdx !== null && endIdx !== null;
            $('#btn-add').disabled = !hasSel;
        }

        function updateSelectionHighlight() {
            $$('.token').forEach(s => s.dataset.selected = 'false');
            const { startIdx, endIdx } = state.selection;
            if (startIdx === null || endIdx === null) return;
            for (let i = startIdx; i <= endIdx; i++) {
                const node = document.querySelector(`.token[data-idx="${i}"]`);
                if (node) node.dataset.selected = 'true';
            }
        }

        function clearSelection() {
            state.selection.startIdx = state.selection.endIdx = null;
            updateSelectionHighlight();
            $('#btn-add').disabled = true;
        }

        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') clearSelection(); });

        // ============== Modal (create/edit) ==============
        function openModal(mode = 'create', annoId = null) {
            ui.mode = mode; ui.editId = annoId;
            const bd = $('#modal-bd');
            bd.style.display = 'flex';

            const title = (mode === 'edit') ? 'Edit Annotation' : 'Add Class';
            $('#modal-title').textContent = title;

            // Prefill label
            const labelNode = $('#inp-label');
            if (mode === 'create') labelNode.value = surfaceFormFromSelection();

            // Class select
            // Destroy any previous Choices instance (important if modal reused)
            if (window.classChoices) {
                window.classChoices.destroy();
                window.classChoices = null;
            }

            const sel = $('#sel-class');
            sel.innerHTML = '';
            for (const cls of Object.keys(state.classes)) {
                sel.appendChild(el('option', { value: cls }, [cls]));
            }

            // Initialize Choices.js
            window.classChoices = new Choices(sel, {
                searchEnabled: true,      // enable search
                searchPlaceholderValue: 'Search classes…',
                shouldSort: false,        // keep your original order
                maxItemCount: -1,         // no limit
                itemSelectText: '',       // remove “Press to select” hint
                position: 'bottom',       // open downward
                allowHTML: false
            });

            // inside openModal(...), after initializing Choices:
            clearSemanticSuggestions();

            // Check backend readiness once per modal open (cheap call / fast path)
            API.semanticStatus().then(s => {
                const b = $('#btn-sem-find');
                b.disabled = !(s.ready && s.has_embedder && s.size > 0);
                b.title = b.disabled ? 'Semantic index not ready' : 'Send search + label to semantic engine';
            });

            // Listen for changes
            sel.addEventListener('change', () => { renderAttrFields(); renderClassDescription(); });

            // If editing, set current values
            if (mode === 'edit') {
                const anno = state.annotations.find(a => a.id === annoId);
                if (!anno) return;
                labelNode.value = anno.label || '';
                sel.value = anno.class;
                renderAttrFields(anno.attrs);
                renderClassDescription();
                $('#btn-delete').style.display = 'inline-flex';
            } else {
                renderAttrFields();
                renderClassDescription();
                $('#btn-delete').style.display = 'none';
            }
        }

        function closeModal() { $('#modal-bd').style.display = 'none'; }

        // ADD: overwrite modal opener (re-use if you already added earlier)
        function openOverwriteModal(onConfirm, onCancel) {
            const bd = $('#overwrite-bd');
            bd.style.display = 'flex';
            const ok = $('#btn-overwrite-confirm');
            const cancel = $('#btn-overwrite-cancel');
            const cleanup = () => { ok.onclick = cancel.onclick = null; bd.style.display = 'none'; };
            ok.onclick = () => { cleanup(); onConfirm && onConfirm(); };
            cancel.onclick = () => { cleanup(); onCancel && onCancel(); };
        }

        // ADD: Delete All modal opener
        function openDeleteAllModal(onConfirm, onCancel) {
            const bd = $('#delall-bd');
            bd.style.display = 'flex';

            const ok = $('#btn-delall-confirm');
            const cancel = $('#btn-delall-cancel');

            const cleanup = () => {
                ok.onclick = cancel.onclick = null;
                bd.style.display = 'none';
            };
            // on ok click -> delete all button turn disabled
            ok.onclick = () => { cleanup(); onConfirm && onConfirm(); $('#btn-delete-all').disabled = true; };
            cancel.onclick = () => { cleanup(); onCancel && onCancel(); };
        }


        function renderAttrFields(prefill = {}) {
            const wrap = $('#attrs');
            wrap.innerHTML = '';
            const clsName = $('#sel-class').value;
            const meta = state.classes[clsName];
            if (!meta || !meta.attributes || Object.keys(meta.attributes).length === 0) {
                wrap.appendChild(el('div', { className: 'empty' }, ['No attributes.'])); return;
            }

            for (const [attr, spec] of Object.entries(meta.attributes)) {
                const field = el('div', { className: 'row', style: 'align-items:center' }, [
                    el('label', { style: 'width: 160px; color: var(--muted);' }, [attr]),
                ]);

                let input;
                if (spec.enum) {
                    input = el('select', { id: `attr-${attr}`, style: 'margin-top:5px' }, spec.enum.map(v => el('option', { value: v }, [v])));
                    if (spec.nullable) input.prepend(el('option', { value: '', textContent: '(none)' }));
                } else if (spec.type === 'number') {
                    input = el('input', { id: `attr-${attr}`, type: 'number', step: 'any', placeholder: 'num', style: 'margin-top:5px;width:100px' });
                } else {
                    input = el('input', { id: `attr-${attr}`, type: 'text', placeholder: 'text' });
                }

                // Prefill if provided
                const val = prefill[attr];
                if (val !== undefined && val !== null) {
                    input.value = String(val);
                } else if (val === null && spec.nullable) {
                    input.value = '';
                }

                field.appendChild(input);
                wrap.appendChild(field);
            }
        }

        function surfaceFormFromSelection() {
            const { startIdx, endIdx } = state.selection;
            if (startIdx === null || endIdx === null) return '';
            const parts = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const t = state.tokens[i];
                if (!t || t.isSpace) continue;
                parts.push(t.text);
                const after = state.tokens[i + 1];
                if (after && after.isSpace) parts.push(after.text);
            }
            return parts.join('').trim();
        }

        function confirmSaveAnnotation() {
            const mode = ui.mode;
            const label = $('#inp-label').value.trim() || surfaceFormFromSelection();
            const klass = $('#sel-class').value;

            // collect attrs
            const attrs = {};
            const meta = state.classes[klass] || { attributes: {} };
            for (const [attr, spec] of Object.entries(meta.attributes || {})) {
                const node = document.querySelector(`#attr-${attr}`);
                if (!node) continue;
                const raw = node.value;
                if (raw === '' && spec.nullable) { attrs[attr] = null; continue; }
                if (spec.type === 'number') attrs[attr] = raw === '' ? null : Number(raw);
                else attrs[attr] = raw;
            }

            if (mode === 'create') {
                const { startIdx, endIdx } = state.selection;
                if (startIdx === null || endIdx === null) return;
                const start = Number(document.querySelector(`.token[data-idx="${startIdx}"]`).dataset.start);
                const end = Number(document.querySelector(`.token[data-idx="${endIdx}"]`).dataset.end);
                const anno = {
                    id: `T${state.annotations.length + 1}`,
                    class: klass,
                    label,
                    attrs,
                    span: { start, end },
                    tokenRange: [startIdx, endIdx]
                };
                state.annotations.push(anno);
            } else if (mode === 'edit') {
                const anno = state.annotations.find(a => a.id === ui.editId);
                if (!anno) return;
                anno.class = klass;
                anno.label = label;
                anno.attrs = attrs;
            }

            ui.dirty = true;
            updatePrimaryButton();
            applyAnnotationHighlights();
            renderLegend();
            closeModal();
            clearSelection();
        }

        function deleteAnnotation() {
            if (ui.mode !== 'edit') return;
            const id = ui.editId;
            state.annotations = state.annotations.filter(a => a.id !== id);
            // if no current annotations left, disable Delete all button
            if (state.annotations.length === 0) { $('#btn-delete-all').disabled = true; }
            ui.dirty = true;
            updatePrimaryButton();
            applyAnnotationHighlights();
            renderLegend();
            closeModal();
        }

        // ADD

        function updatePrimaryButton() {
            const btn = $('#btn-save');
            const shouldSkip = state.saved.exists && !ui.dirty; // already annotated & untouched
            btn.textContent = shouldSkip ? 'Skip ▶' : 'Save & Next ▶';
            // Always enabled: we either skip or save
            btn.disabled = false;
        }

        // ADD: map a char-span to token indices (inclusive range)
        function spanToTokenRange(span) {
            const { start, end } = span; // end is exclusive
            let i0 = null, i1 = null;
            for (let i = 0; i < state.tokens.length; i++) {
                const t = state.tokens[i];
                if (t.isSpace) continue;
                if (i0 === null && t.end > start) i0 = i;           // first token that crosses/starts after start
                if (t.start < end) i1 = i;                          // last token whose start is before end
                if (t.start >= end) break;
            }
            if (i0 === null || i1 === null) return null;
            return [i0, i1];
        }

        // ============== Wire up UI ==============
        $('#btn-add').onclick = () => openModal('create');
        $('#btn-cancel').onclick = closeModal;
        $('#btn-confirm').onclick = confirmSaveAnnotation;
        $('#btn-delete').onclick = deleteAnnotation;
        $('#btn-clear').onclick = clearSelection;
        // ADD: Find button
        $('#btn-sem-find').onclick = async () => {
            const btn = $('#btn-sem-find');
            try {
                btn.classList.add('loading');
                const query = getChoicesSearchTerm();  // from Choices search
                const label = $('#inp-label').value.trim(); // the surface form box
                const res = await API.semanticSuggest({ query, label, top_k: 8, threshold: 0.2 });
                renderSemanticSuggestions(res.items);
            } catch (e) {
                console.error(e);
                alert('Semantic search failed: ' + e.message);
            } finally {
                btn.classList.remove('loading');
            }
        };

        // ADD: Press Enter in the Choices search input triggers Find
        document.addEventListener('keydown', (ev) => {
            const active = document.activeElement;
            if (ev.key === 'Enter' && active && active.classList.contains('choices__input--cloned')) {
                ev.preventDefault();
                const btn = $('#btn-sem-find');
                if (!btn.disabled) btn.click();
            }
        });

        // ADD: on openModal, clear previous suggestions
        function clearSemanticSuggestions() {
            $('#sem-suggest').innerHTML = '';
            $('#sem-suggest-section').style.display = 'none';
        }

        $('#btn-save').onclick = async () => {
            try {
                const shouldSkip = state.saved.exists && !ui.dirty;

                if (shouldSkip) {
                    // Just advance without saving
                    setStatus('Skipping…');
                    const data = await API.getNextText(state.texts.cursor + 1);
                    loadTextResponse(data);
                    return;
                }

                // Otherwise: Save (may overwrite)
                const payload = buildAnnotationPayload();

                const proceedSave = async (overwrite) => {
                    await API.saveAnnotations(payload, overwrite);
                    ui.dirty = false; // saved
                    updatePrimaryButton();
                    setStatus('Saved. Loading next text…');
                    const data = await API.getNextText(state.texts.cursor + 1);
                    loadTextResponse(data);
                };

                // Fetch existing to decide overwrite confirmation
                const existing = await API.getAnnotation(payload.text_id); // null if none

                if (existing && Array.isArray(existing.entities) && existing.entities.length > 0) {
                    openOverwriteModal(
                        () => proceedSave(true),
                        () => setStatus('Save canceled.')
                    );
                } else {
                    await proceedSave(!!existing); // overwrite=true only if an empty record exists
                }
            } catch (e) {
                console.error(e);
                alert('Save failed: ' + e.message);
            }
        };

        $('#btn-prev').onclick = async () => {
            try {
                const data = await API.getPrevText(Math.max(0, state.texts.cursor - 1));
                loadTextResponse(data);
            } catch (e) { console.error(e); }
        };

        // Delete all annotations for the current text
        $('#btn-delete-all').onclick = () => {
            if (state.annotations.length === 0) return;
            openDeleteAllModal(
                () => {
                    state.annotations = [];
                    ui.dirty = true;          // user changed the current doc
                    updatePrimaryButton(); // update Save/Skip button
                    applyAnnotationHighlights();
                    renderLegend();
                    clearSelection();
                    setStatus('All annotations cleared.');
                },
                () => setStatus('Delete all canceled.')
            );
        };

        function buildAnnotationPayload() {
            return {
                text_id: state.current.id,
                text: state.current.text,
                entities: state.annotations.map(a => ({
                    id: a.id,
                    class: a.class,
                    label: a.label,
                    span: { start: a.span.start, end: a.span.end },
                    attributes: a.attrs
                }))
            };
        }
        // REPLACE
        async function loadTextResponse(data) {
            state.current = { id: data.id, text: data.text };
            state.texts.cursor = data.cursor;
            state.texts.total = data.total;

            // Reset local annotations & selection
            state.annotations = [];
            clearSelection();

            // Reset saved flags & hide note by default
            state.saved.exists = false;
            state.saved.wasEmpty = false;
            $('#empty-annot-note').style.display = 'none';

            // Render tokens first
            renderText();

            try {
                const saved = await API.getAnnotation(state.current.id); // null if none
                if (saved && Array.isArray(saved.entities)) {
                    state.saved.exists = true;
                    state.saved.wasEmpty = saved.entities.length === 0;

                    if (state.saved.wasEmpty) {
                        // Informative note under the textbox
                        $('#empty-annot-note').style.display = 'block';
                    }

                    // Map saved entities to UI annotations
                    const annos = [];
                    for (const ent of saved.entities) {
                        const tr = spanToTokenRange(ent.span);
                        if (!tr) continue;
                        annos.push({
                            id: ent.id,
                            class: ent.class,
                            label: ent.label,
                            attrs: ent.attributes || {},
                            span: { start: ent.span.start, end: ent.span.end },
                            tokenRange: tr
                        });
                    }
                    state.annotations = annos;
                    applyAnnotationHighlights();
                    renderLegend();
                    setStatus(`Doc ${data.cursor + 1} / ${data.total} (loaded saved annotations)`);
                } else {
                    // No saved annotation
                    renderLegend();
                    setStatus(`Doc ${data.cursor + 1} / ${data.total}`);
                }
            } catch (e) {
                // 404 → no saved annotations
                renderLegend();
                setStatus(`Doc ${data.cursor + 1} / ${data.total}`);
            }

            // Fresh load: untouched
            ui.dirty = false;
            updatePrimaryButton();
        }


        async function boot() {
            try {
                state.classes = await API.getClasses();
                const data = await API.getNextText(null);
                loadTextResponse(data);
            } catch (e) { console.error(e); setStatus('Failed to initialize. Is the backend running?'); }
        }

        boot();
    </script>
</body>

</html>